import axios from 'axios';
import { Channel } from '@shared/schema';

/**
 * Serviço de integração com a Z-API (WhatsApp)
 * 
 * Implementa todas as funcionalidades da Z-API para envio e recebimento
 * de mensagens do WhatsApp.
 */

// Configuração global
// Configurações da instância web (valores das variáveis de ambiente ou valores padrão se não definidos)
const ZAPI_TOKEN = process.env.ZAPI_TOKEN || "A4E42029C248B72DA0842F47";
const ZAPI_INSTANCE_ID = process.env.ZAPI_INSTANCE_ID || "3DF871A7ADFB20FB49998E66062CE0C1";

// Usar CLIENT_TOKEN_ZAPI fornecido pelo usuário como primeira opção, depois cair para os outros
const ZAPI_CLIENT_TOKEN = process.env.CLIENT_TOKEN_ZAPI || 
                          process.env.ZAPI_CLIENT_TOKEN || 
                          "Fa427b12e188a433292a658fe45a07714S";

// Configurações alternativas da instância mobile para testes
const ZAPI_MOBILE_TOKEN = "8A82365003962876A3574828";
const ZAPI_MOBILE_INSTANCE_ID = "3D0C1D6E493402738F4C266504411D32";

const BASE_URL = 'https://api.z-api.io';

// Z-API Security Token (Token de Segurança da conta, diferente do token da instância)
// Este token é usado em todas as instâncias
const ZAPI_SECURITY_TOKEN = "Fa427b12e188a433292a658fe45a07714S";

/**
 * Função auxiliar para formatar botões no formato Z-API
 * @param buttons Array de botões no formato simples ({ text: string }) ou parcial ({ buttonText: string })
 * @param useActionButtons Flag para usar formato alternativo (não usado atualmente)
 * @returns Array de botões no formato oficial Z-API (com buttonId e buttonText.displayText)
 */
export function formatButtonsForZAPI(buttons: any[], useActionButtons = false) {
  // No formato para send-button-list, os botões devem estar no formato:
  // { id: string, text: string }
  // conforme https://developer.z-api.io/message/send-button-list
  
  return buttons.map((button, index) => {
    // Para mensagens com botões, o formato deve ser { id: string, text: string }
    return {
      id: button.id || button.buttonId || `btn_${index + 1}`,
      text: button.text || button.buttonText?.displayText || button.buttonText || ""
    };
  });
}

// Log inicial das configurações para diagnóstico
console.log("=================== CONFIGURAÇÃO Z-API ===================");
console.log(`ZAPI_INSTANCE_ID: ${ZAPI_INSTANCE_ID}`);
console.log(`ZAPI_TOKEN: ${ZAPI_TOKEN}`);
console.log(`Client-Token definido: ${ZAPI_CLIENT_TOKEN ? "SIM" : "NÃO"}`);
console.log(`Origem do Client-Token: ${
  process.env.CLIENT_TOKEN_ZAPI ? "CLIENT_TOKEN_ZAPI" : 
  (process.env.ZAPI_CLIENT_TOKEN ? "ZAPI_CLIENT_TOKEN" : "Valor padrão")
}`);
console.log("==========================================================");

// Função de ajuda para garantir que incluímos sempre o Client-Token nos headers
function getHeadersWithToken(token: string, clientToken: string = ZAPI_CLIENT_TOKEN) {
  // IMPORTANTE: De acordo com a documentação da Z-API e a coleção do Postman,
  // o formato correto do header é 'Client-Token' (com C e T maiúsculos)
  // https://www.postman.com/docs-z-api/z-api-s-public-workspace/folder/4aisbsg/messages
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    'Client-Token': clientToken,
  };
  
  // Log para diagnóstico
  console.log(`[Z-API] Headers configurados:`, JSON.stringify(headers));
  
  return headers;
}

/**
 * Testa a conexão com as instâncias Z-API (web e mobile)
 * Esta função é útil para diagnóstico das credenciais da Z-API
 */
export async function testZapiInstances(): Promise<{
  webInstance: {
    success: boolean;
    message: string;
    data?: any;
  },
  mobileInstance: {
    success: boolean;
    message: string;
    data?: any;
  }
}> {
  const result = {
    webInstance: {
      success: false,
      message: "Não testado"
    },
    mobileInstance: {
      success: false,
      message: "Não testado"
    }
  };
  
  // Testar a instância web
  try {
    console.log(`Testando instância web Z-API (${ZAPI_INSTANCE_ID})...`);
    const webResponse = await axios.get(
      `${BASE_URL}/instances/${ZAPI_INSTANCE_ID}/token/${ZAPI_TOKEN}/status`,
      { headers: getHeadersWithToken(ZAPI_TOKEN) }
    );
    
    result.webInstance = {
      success: true,
      message: "Conexão bem-sucedida",
      data: webResponse.data
    };
  } catch (error) {
    console.error(`Erro ao testar instância web Z-API:`, error);
    if (axios.isAxiosError(error)) {
      result.webInstance = {
        success: false,
        message: `Erro ${error.response?.status}: ${error.response?.data?.error || error.message}`,
        data: error.response?.data
      };
    } else {
      result.webInstance = {
        success: false,
        message: error instanceof Error ? error.message : "Erro desconhecido"
      };
    }
  }
  
  // Testar a instância mobile
  try {
    console.log(`Testando instância mobile Z-API (${ZAPI_MOBILE_INSTANCE_ID})...`);
    const mobileResponse = await axios.get(
      `${BASE_URL}/instances/${ZAPI_MOBILE_INSTANCE_ID}/token/${ZAPI_MOBILE_TOKEN}/status`,
      { headers: getHeadersWithToken(ZAPI_MOBILE_TOKEN) }
    );
    
    result.mobileInstance = {
      success: true,
      message: "Conexão bem-sucedida",
      data: mobileResponse.data
    };
  } catch (error) {
    console.error(`Erro ao testar instância mobile Z-API:`, error);
    if (axios.isAxiosError(error)) {
      result.mobileInstance = {
        success: false,
        message: `Erro ${error.response?.status}: ${error.response?.data?.error || error.message}`,
        data: error.response?.data
      };
    } else {
      result.mobileInstance = {
        success: false,
        message: error instanceof Error ? error.message : "Erro desconhecido"
      };
    }
  }
  
  return result;
}

/**
 * Configura o canal Z-API
 * @param channel Canal configurado no sistema
 * @returns Status da configuração com QR Code se necessário
 */
export async function setupZAPIChannel(channel: Channel): Promise<{ status: string; message?: string; qrCode?: string }> {
  try {
    // Verifica se as credenciais estão disponíveis
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;

    if (!instanceId || !token) {
      console.log(`[Z-API] Erro: Credenciais não configuradas para canal ${channel.id}`);
      return {
        status: "error",
        message: "Credenciais da Z-API não configuradas (instanceId, token)"
      };
    }

    console.log(`[Z-API] Configurando canal ${channel.id} (${channel.name})`);
    console.log(`[Z-API] Instância: ${instanceId}`);
    console.log(`[Z-API] Token: ${token.substring(0, 8)}...`);
    console.log(`[Z-API] Client-Token: ${clientToken ? "Configurado" : "Não configurado"}`);

    // Configurar webhook para recebimento de mensagens (PASSO CRUCIAL)
    console.log(`[Z-API] Iniciando configuração do webhook para canal ${channel.id}...`);
    
    // Determinar a URL base da aplicação para webhooks
    let baseUrl = '';
    if (process.env.APP_URL) {
      baseUrl = process.env.APP_URL;
    } else if (process.env.REPLIT_DOMAINS) {
      baseUrl = `https://${process.env.REPLIT_DOMAINS.split(',')[0]}`;
    } else {
      // URL da Replit atual baseada na ID do projeto
      baseUrl = 'https://0eb8be2b-04a6-47e5-bbf1-dd3bd83018b0-00-2m0jsmtd34bj0.picard.replit.dev';
    }
    
    // URL do webhook específica para este canal
    const webhookUrl = `${baseUrl}/api/webhooks/zapi/${channel.id}`;
    console.log(`[Z-API] URL do webhook a ser configurada: ${webhookUrl}`);
    
    // Chamar a função configureWebhook com todos os eventos necessários ativados e URL explícita
    const webhookResult = await configureWebhook(channel, webhookUrl, {
      receiveAllNotifications: true,
      messageReceived: true,
      messageCreate: true,
      statusChange: true,
      presenceChange: true,
      deviceConnected: true
    });
    
    if (webhookResult.status === "success") {
      console.log(`[Z-API] Webhook configurado com sucesso: ${webhookResult.webhookUrl}`);
      
      // Armazenar a URL do webhook na configuração do canal para referência futura
      try {
        // Importar db para atualizar o canal
        const { db } = await import("../../db");
        const { channels } = await import("../../shared/schema");
        const { eq } = await import("drizzle-orm");
        
        // Atualizar a configuração do canal com informações do webhook
        const updatedConfig = {
          ...(channel.config as Record<string, any>),
          webhookUrl: webhookResult.webhookUrl
        };
        
        await db.update(channels)
          .set({ config: updatedConfig })
          .where(eq(channels.id, channel.id));
          
        console.log(`[Z-API] Configuração do canal atualizada com URL do webhook`);
      } catch (dbError) {
        console.error("[Z-API] Erro ao atualizar configuração do canal:", dbError);
        // Continuamos mesmo com erro de atualização do canal
      }
    } else {
      console.warn(`[Z-API] Alerta: Problema na configuração do webhook: ${webhookResult.message}`);
      // Continuamos o fluxo mesmo com erro no webhook, mas registramos o alerta
    }

    try {
      // Verifica status da conexão
      const statusResponse = await axios.get(
        `${BASE_URL}/instances/${instanceId}/token/${token}/status`,
        {
          headers: getHeadersWithToken(token)
        }
      );

      // Se o status indicar que não está conectado, gera QR Code
      if (statusResponse.data && statusResponse.data.connected === false) {
        try {
          // Gera QR Code - modificando para usar endpoint correto e tratar resposta apropriadamente
          // De acordo com a documentação, devemos usar o endpoint qr-code
          const headers: Record<string, string> = {
            ...getHeadersWithToken(token),
            'Accept': 'image/png, application/json',
            'Content-Type': 'application/json'
          };
          
          const qrResponse = await axios.get(
            `${BASE_URL}/instances/${instanceId}/token/${token}/qr-code`,
            {
              headers,
              // Configurar para receber resposta em formato binário
              responseType: 'arraybuffer',
              // Garantir que não receberemos HTML (que causaria erro de parsing)
              validateStatus: function (status) {
                return status >= 200 && status < 300; // Aceitar apenas status 2xx
              }
            }
          );

          // Verificar se temos uma resposta de imagem
          if (qrResponse.data) {
            // Converter o buffer recebido para base64
            const qrCodeBase64 = Buffer.from(qrResponse.data).toString('base64');
            
            console.log("QR Code recebido com sucesso e convertido para base64");
            
            return {
              status: "pending",
              message: "Escaneie o QR Code com o WhatsApp para conectar",
              qrCode: qrCodeBase64
            };
          } else {
            console.error("QR Code retornou dados vazios");
            return {
              status: "error",
              message: "Falha ao gerar QR Code para conexão: resposta vazia"
            };
          }
        } catch (error) {
          console.error("Erro ao obter QR Code:", error);
          return {
            status: "error",
            message: `Falha ao gerar QR Code para conexão: ${error instanceof Error ? error.message : "erro desconhecido"}`
          };
        }
      }

      // Webhook já foi configurado anteriormente no fluxo

      return {
        status: "success",
        message: "Canal Z-API WhatsApp configurado com sucesso"
      };
    } catch (error) {
      console.error("Erro ao configurar Z-API:", error);
      return {
        status: "error",
        message: "Falha ao configurar Z-API"
      };
    }
  } catch (error) {
    console.error("Erro ao configurar canal Z-API:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao configurar Z-API"
    };
  }
}

/**
 * Envia mensagem de texto via Z-API
 * @param channel Canal configurado 
 * @param to Número de telefone de destino
 * @param content Conteúdo da mensagem
 * @returns Status do envio com ID da mensagem
 */
export async function sendTextMessage(
  channel: Channel,
  to: string,
  content: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Formatação do número do WhatsApp de acordo com a documentação ATUAL da Z-API
    // Remove todos os caracteres não numéricos
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API] Enviando texto para ${formattedPhone} (original: ${to}): "${content}"`);
    console.log(`[Z-API] Usando instância: ${instanceId} e token: ${token.slice(0, 5)}...`);
    
    // Headers completos conforme a documentação atualizada
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    console.log(`[Z-API] Headers:`, JSON.stringify(headers));
    
    // Enviar mensagem usando o endpoint correto conforme documentação atual:
    // https://developer.z-api.io/message/send-message-text
    const url = `${BASE_URL}/instances/${instanceId}/token/${token}/send-text`;
    
    console.log(`[Z-API] URL de envio: ${url}`);
    
    // Payload conforme a documentação atual da Z-API
    const payload = {
      phone: formattedPhone,
      message: content,
      isGroup: false // Assumindo que não é grupo por padrão
    };
    
    console.log(`[Z-API] Payload:`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(url, payload, { headers });
    
    console.log(`[Z-API] Resposta de envio:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme a documentação atualizada
    if (response.data) {
      if (response.data.messageId || response.data.id || response.data.zaapId) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId;
        console.log(`[Z-API] Mensagem enviada com sucesso, ID: ${messageId}`);
        return {
          status: "success",
          messageId: messageId
        };
      } else if (response.data.value === true || response.data.sent === true) {
        // Algumas versões da API retornam o campo value/sent como true para indicar sucesso
        console.log(`[Z-API] Mensagem enviada com sucesso, resposta sem ID`);
        
        // Verificar se há algum outro identificador na resposta
        const alternativeId = response.data.id || response.data.messageId || response.data.messageId || Date.now().toString();
        
        return {
          status: "success",
          messageId: alternativeId
        };
      } else if (typeof response.data === 'string' && response.data.includes('success')) {
        // Algumas versões podem retornar apenas uma string de sucesso
        console.log(`[Z-API] Mensagem enviada com sucesso, resposta em formato string`);
        return {
          status: "success",
          messageId: `msg_${Date.now()}`
        };
      }
    }
    
    // Se chegamos até aqui, a resposta não tem o formato esperado
    console.error(`[Z-API] Resposta de envio em formato inesperado:`, response.data);
    
    // Tentar interpretar mesmo assim para evitar falsos negativos
    if (response.status >= 200 && response.status < 300) {
      console.log(`[Z-API] Considerando mensagem enviada pelo código HTTP ${response.status} de sucesso`);
      return {
        status: "success",
        messageId: `unknown_${Date.now()}`,
        message: "Mensagem possivelmente enviada, mas formato de resposta não reconhecido"
      };
    }
    
    return {
      status: "error",
      message: "Falha ao enviar mensagem via Z-API: Resposta em formato não reconhecido"
    };
  } catch (error) {
    console.error("Erro ao enviar mensagem Z-API:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      // Se o erro incluir 'Could not find source instance', a instância pode estar desconectada
      if (error.response?.data?.error?.includes('find source instance') || 
          error.response?.data?.message?.includes('find source instance')) {
        return {
          status: "error",
          message: "Instância Z-API não encontrada ou desconectada. Verifique a conexão do WhatsApp."
        };
      }
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.response?.data?.message || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar mensagem Z-API"
    };
  }
}

/**
 * Envia mensagem de imagem via Z-API
 * @param channel Canal configurado
 * @param to Número de telefone de destino
 * @param caption Legenda da imagem
 * @param imageUrl URL da imagem
 * @returns Status do envio com ID da mensagem
 */
export async function sendImageMessage(
  channel: Channel,
  to: string,
  caption: string,
  imageUrl: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Formatação correta do número do WhatsApp de acordo com documentação Z-API
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API] Enviando imagem para ${formattedPhone} (original: ${to})`);
    console.log(`[Z-API] URL da imagem: ${imageUrl}`);
    
    // Headers atualizados conforme documentação
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Enviar imagem usando a estrutura correta do payload conforme documentação oficial
    // https://developer.z-api.io/message/send-message-image
    console.log(`[Z-API DEBUG] Enviando imagem com formato correto...`);
    
    // Verificar se a URL começa com "data:" para identificar Base64
    const isBase64 = imageUrl.startsWith('data:');
    
    // Preparar o payload baseado no tipo de entrada (URL ou Base64)
    const payload: Record<string, any> = {
      phone: formattedPhone,
      caption: caption || ''
    };
    
    // Adicionar campo correto baseado no tipo de entrada
    if (isBase64) {
      console.log(`[Z-API] Enviando imagem como Base64`);
      payload.image = imageUrl; // Base64 com prefixo data:image/png;base64,
    } else {
      console.log(`[Z-API] Enviando imagem como URL`);
      payload.image = imageUrl; // URL direta para imagem
    }
    
    console.log(`[Z-API] Payload (parcial): { phone: "${formattedPhone}", caption: "${caption}", image: "${imageUrl.substring(0, 30)}..." }`);
    
    const response = await axios.post(
      `${BASE_URL}/instances/${instanceId}/token/${token}/send-image`,
      payload,
      { headers }
    );
    
    console.log(`[Z-API DEBUG] Resposta de envio de imagem:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme documentação
    if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
      const messageId = response.data.messageId || response.data.id || response.data.zaapId;
      console.log(`[Z-API] Imagem enviada com sucesso, ID: ${messageId}`);
      return {
        status: "success",
        messageId: messageId
      };
    } else if (response.data && response.data.value) {
      // Algumas versões da API retornam o campo value como true para indicar sucesso
      console.log(`[Z-API] Imagem enviada com sucesso, resposta sem ID (usar Z-API mais recente)`);
      return {
        status: "success",
        messageId: "unknown" // Não temos ID neste caso
      };
    } else {
      console.error(`[Z-API] Resposta de erro ao enviar imagem:`, response.data);
      return {
        status: "error",
        message: "Falha ao enviar imagem via Z-API: Resposta sem ID de mensagem"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar imagem Z-API:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar imagem Z-API"
    };
  }
}

/**
 * Envia mensagem de documento/arquivo via Z-API
 * @param channel Canal configurado
 * @param to Número de telefone de destino
 * @param caption Legenda do documento
 * @param fileUrl URL do arquivo
 * @param fileName Nome do arquivo
 * @returns Status do envio com ID da mensagem
 */
export async function sendDocumentMessage(
  channel: Channel,
  to: string,
  caption: string,
  fileUrl: string,
  fileName: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Formatação correta do número do WhatsApp de acordo com documentação Z-API
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API] Enviando documento para ${formattedPhone} (original: ${to}): ${fileName}`);
    
    // Headers atualizados conforme documentação 
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    console.log(`[Z-API] Headers para envio de documento:`, JSON.stringify(headers));
    
    // Enviar documento usando o payload correto de acordo com a documentação
    // https://developer.z-api.io/message/send-message-document
    console.log(`[Z-API DEBUG] Enviando documento usando documentação atualizada`);
    
    // Verificar se é base64 ou URL
    const isBase64 = fileUrl.startsWith('data:');
    
    // Montar payload de acordo com o tipo
    const payload: Record<string, any> = {
      phone: formattedPhone,
      fileName: fileName,
      // Remover texto automático "📄 Documento" da caption
      caption: caption === "📄 Documento" ? "" : (caption || '')
    };
    
    // Adicionar o campo correto de acordo com a documentação atualizada
    if (isBase64) {
      console.log(`[Z-API] Enviando documento como Base64`);
      payload.document = fileUrl;
    } else {
      console.log(`[Z-API] Enviando documento como URL`);
      payload.document = fileUrl;
    }
    
    // Extrair a extensão do arquivo
    const fileExtension = fileName.split('.').pop()?.toLowerCase() || '';
    if (!fileExtension) {
      console.warn(`[Z-API] AVISO: Não foi possível extrair a extensão do arquivo "${fileName}". Usando "txt" como padrão.`);
    }
    
    // Incluir a extensão no endpoint conforme documentação
    const extension = fileExtension || 'txt';
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-document/${extension}`;
    
    console.log(`[Z-API] Enviando para endpoint com extensão: ${endpoint}`);
    
    const response = await axios.post(
      endpoint,
      payload,
      { headers }
    );
    
    console.log(`[Z-API] Resposta de envio de documento:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme documentação
    if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
      const messageId = response.data.messageId || response.data.id || response.data.zaapId;
      console.log(`[Z-API] Documento enviado com sucesso, ID: ${messageId}`);
      return {
        status: "success",
        messageId: messageId
      };
    } else if (response.data && response.data.value) {
      // Algumas versões da API retornam o campo value como true para indicar sucesso
      console.log(`[Z-API] Documento enviado com sucesso, resposta sem ID (usar Z-API mais recente)`);
      return {
        status: "success",
        messageId: "unknown" // Não temos ID neste caso
      };
    } else {
      console.error(`[Z-API] Resposta de erro ao enviar documento:`, response.data);
      return {
        status: "error",
        message: "Falha ao enviar documento via Z-API: Resposta sem ID de mensagem"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar documento Z-API:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar documento Z-API"
    };
  }
}

/**
 * Envia mensagem de vídeo via Z-API
 * @param channel Canal configurado
 * @param to Número de telefone de destino
 * @param videoUrl URL do vídeo a ser enviado
 * @param caption Legenda opcional para o vídeo
 * @returns Status do envio com ID da mensagem
 */
export async function sendVideoMessage(
  channel: Channel,
  to: string,
  videoUrl: string,
  caption?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Formatação do número do WhatsApp conforme documentação
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API DEBUG] Enviando vídeo para ${formattedPhone} (original: ${to}): "${videoUrl}"`);
    console.log(`[Z-API DEBUG] Caption: "${caption || 'sem legenda'}"`);
    console.log(`[Z-API DEBUG] Token: "${token.substring(0, 4)}...${token.substring(token.length - 4)}"`);
    console.log(`[Z-API DEBUG] InstanceID: "${instanceId}"`);
    
    // Headers completos para requisição
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de vídeo
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-video`;
    console.log(`[Z-API DEBUG] Chamando endpoint: ${endpoint}`);
    
    // Faremos múltiplas tentativas com diferentes formatos aceitos pela API
    let lastError: any = null;
    
    // Verificar se é base64 ou URL
    const isBase64 = videoUrl.startsWith('data:');
    
    // Tentativa 1: Usando o campo correto conforme a documentação mais recente
    try {
      console.log(`[Z-API DEBUG] Tentativa 1: Usando campo 'video' ${isBase64 ? '(Base64)' : '(URL)'}`);
      const response = await axios.post(
        endpoint,
        {
          phone: formattedPhone,
          video: videoUrl,
          caption: caption === "🎬 Vídeo" ? "" : (caption || '')
        },
        { headers }
      );
      
      console.log(`[Z-API DEBUG] Resposta 1:`, JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId || response.data.value === true)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId || "unknown";
        return {
          status: "success",
          messageId
        };
      }
    } catch (err: any) {
      console.error("[Z-API DEBUG] Erro na tentativa 1:", err.message);
      lastError = err;
    }
    
    // Tentativa 2: Usando linkVideo (documentação anterior)
    try {
      console.log("[Z-API DEBUG] Tentativa 2: Usando campo 'linkVideo'");
      const response = await axios.post(
        endpoint,
        {
          phone: formattedPhone,
          linkVideo: videoUrl,
          caption: caption === "🎬 Vídeo" ? "" : (caption || '')
        },
        { headers }
      );
      
      console.log(`[Z-API DEBUG] Resposta 2:`, JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId || response.data.value === true)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId || "unknown";
        return {
          status: "success",
          messageId
        };
      }
    } catch (err: any) {
      console.error("[Z-API DEBUG] Erro na tentativa 2:", err.message);
      lastError = err;
    }
    
    // Tentativa 3: Usando o endpoint genérico send-media
    try {
      console.log("[Z-API DEBUG] Tentativa 3: Usando endpoint 'send-media'");
      const mediaEndpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-media`;
      
      const response = await axios.post(
        mediaEndpoint,
        {
          phone: formattedPhone,
          url: videoUrl,
          type: 'video',
          caption: caption === "🎬 Vídeo" ? "" : (caption || '')
        },
        { headers }
      );
      
      console.log(`[Z-API DEBUG] Resposta 3:`, JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId || response.data.value === true)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId || "unknown";
        return {
          status: "success",
          messageId
        };
      }
    } catch (err: any) {
      console.error("[Z-API DEBUG] Erro na tentativa 3:", err.message);
      lastError = err;
    }
    
    // Se chegamos aqui, todas as tentativas falharam
    console.error("[Z-API DEBUG] Todas as tentativas de envio de vídeo falharam");
    
    if (lastError && axios.isAxiosError(lastError)) {
      return {
        status: "error",
        message: `Erro Z-API: ${lastError.response?.status || ''} - ${lastError.response?.data?.error || lastError.message}`
      };
    }
    
    return {
      status: "error",
      message: "Falha ao enviar vídeo após múltiplas tentativas"
    };
  } catch (error: any) {
    console.error("[Z-API DEBUG] Erro geral:", error.message);
    return {
      status: "error",
      message: `Erro ao enviar vídeo: ${error.message}`
    };
  }
}

/**
 * Envia mensagem de áudio via Z-API
 * @param channel Canal configurado
 * @param to Número de telefone de destino
 * @param audioUrl URL do arquivo de áudio
 * @returns Status do envio com ID da mensagem
 */
export async function sendAudioMessage(
  channel: Channel,
  to: string,
  audioUrl: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    // Log detalhado para diagnóstico
    console.log("[Z-API] Iniciando envio de áudio");
    console.log(`[Z-API] URL de áudio: ${audioUrl}`);
    
    // Verificar se o áudio é MP3 (compatível com WhatsApp)
    const isMP3 = audioUrl.toLowerCase().includes('.mp3');
    if (!isMP3) {
      console.log(`[Z-API] ALERTA: URL de áudio não parece ser MP3: ${audioUrl}`);
      console.log(`[Z-API] O WhatsApp pode ter problemas reproduzindo áudios que não estejam em formato MP3`);
    }
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Formatação correta do número do WhatsApp de acordo com documentação Z-API
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    // Verificar se o número é um grupo
    const isGroup = to.includes('-group') || to.includes('@g.us');
    
    // Se for um grupo, precisamos usar o ID do grupo sem formatação
    if (isGroup) {
      formattedPhone = to;
      console.log(`[Z-API] Detectado grupo: ${formattedPhone}`);
    } else {
      console.log(`[Z-API] Enviando áudio para contato: ${formattedPhone} (original: ${to})`);
    }
    
    // Headers completos para requisição
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de áudio
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-audio`;
    
    // Estratégia: Tente vários formatos de payload, começando pelo mais recente documentado
    // Cada versão da Z-API pode ter pequenas diferenças
    
    // Tentativa 1: Formato padrão documentado
    try {
      console.log("[Z-API] Tentativa 1: Usando formato oficial da documentação");
      
      // Verificar se é base64 ou URL
      const isBase64Audio = audioUrl.startsWith('data:');
      
      // Payload conforme documentação mais recente
      const payload = {
        phone: formattedPhone,
        audio: audioUrl,     // URL do áudio ou Base64
        viewOnce: false,     // Não é mensagem de visualização única
        waveform: true       // Mostrar ondas sonoras (efeito visual)
      };
      
      console.log(`[Z-API] Enviando áudio como ${isBase64Audio ? 'Base64' : 'URL'}`)
      
      console.log("[Z-API] Enviando payload 1:", JSON.stringify(payload, null, 2));
      
      const response = await axios.post(endpoint, payload, { headers });
      
      console.log("[Z-API] Resposta 1:", JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId;
        console.log(`[Z-API] Áudio enviado com sucesso! ID: ${messageId}`);
        return {
          status: "success",
          messageId
        };
      } else if (response.data && response.data.value === true) {
        // Algumas versões da API retornam apenas {value: true} para indicar sucesso
        console.log(`[Z-API] Áudio enviado com sucesso! (sem ID retornado)`);
        return {
          status: "success",
          messageId: "unknown"
        };
      }
    } catch (err) {
      console.error("[Z-API] Erro na tentativa 1:", err instanceof Error ? err.message : String(err));
      if (axios.isAxiosError(err) && err.response) {
        console.error(`[Z-API] Status: ${err.response.status}, Dados:`, err.response.data);
      }
    }
    
    // Tentativa 2: Formato alternativo (algumas versões anteriores da Z-API)
    try {
      console.log("[Z-API] Tentativa 2: Usando formato alternativo");
      
      // Payload alternativo (algumas implementações anteriores)
      const payload = {
        phone: formattedPhone,
        url: audioUrl,       // Algumas versões usam 'url' em vez de 'audio'
        options: {
          viewOnce: false,
          waveform: true
        }
      };
      
      console.log("[Z-API] Enviando payload 2:", JSON.stringify(payload, null, 2));
      
      const response = await axios.post(endpoint, payload, { headers });
      
      console.log("[Z-API] Resposta 2:", JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId;
        console.log(`[Z-API] Áudio enviado com sucesso (formato alternativo)! ID: ${messageId}`);
        return {
          status: "success",
          messageId
        };
      } else if (response.data && response.data.value === true) {
        console.log(`[Z-API] Áudio enviado com sucesso (formato alternativo, sem ID)!`);
        return {
          status: "success",
          messageId: "unknown"
        };
      }
    } catch (err) {
      console.error("[Z-API] Erro na tentativa 2:", err instanceof Error ? err.message : String(err));
      if (axios.isAxiosError(err) && err.response) {
        console.error(`[Z-API] Status: ${err.response.status}, Dados:`, err.response.data);
      }
    }
    
    // Tentativa 3: Usando endpoint genérico de mídia (última tentativa)
    try {
      console.log("[Z-API] Tentativa 3: Usando endpoint genérico de mídia");
      
      const mediaEndpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-media`;
      
      const payload = {
        phone: formattedPhone,
        url: audioUrl,
        type: 'audio',       // Especificar que é áudio
        caption: ''          // Sem legenda
      };
      
      console.log("[Z-API] Enviando payload 3:", JSON.stringify(payload, null, 2));
      
      const response = await axios.post(mediaEndpoint, payload, { headers });
      
      console.log("[Z-API] Resposta 3:", JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId;
        console.log(`[Z-API] Áudio enviado com sucesso (endpoint genérico)! ID: ${messageId}`);
        return {
          status: "success",
          messageId
        };
      } else if (response.data && response.data.value === true) {
        console.log(`[Z-API] Áudio enviado com sucesso (endpoint genérico, sem ID)!`);
        return {
          status: "success",
          messageId: "unknown"
        };
      }
    } catch (err) {
      console.error("[Z-API] Erro na tentativa 3:", err instanceof Error ? err.message : String(err));
      if (axios.isAxiosError(err) && err.response) {
        console.error(`[Z-API] Status: ${err.response.status}, Dados:`, err.response.data);
      }
    }
    
    // Se chegamos aqui, todas as tentativas falharam
    console.error("[Z-API] Todas as tentativas de envio de áudio falharam");
    return {
      status: "error",
      message: "Falha no envio de áudio: O servidor Z-API não aceitou nenhum dos formatos de envio"
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Erro desconhecido";
    console.error(`[Z-API] Erro geral no envio de áudio: ${errorMessage}`);
    return {
      status: "error",
      message: `Erro ao enviar áudio: ${errorMessage}`
    };
  }
}

/**
 * Sincroniza contatos do WhatsApp via Z-API
 * @param channel Canal configurado
 * @returns Lista de contatos sincronizados
 */
export async function syncContacts(channel: Channel): Promise<{ status: string; message?: string; contacts?: any[] }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Obter contatos
    const response = await axios.get(
      `${BASE_URL}/instances/${instanceId}/token/${token}/contacts`,
      {
        headers: getHeadersWithToken(token)
      }
    );
    
    if (response.data && Array.isArray(response.data.contacts)) {
      return {
        status: "success",
        contacts: response.data.contacts
      };
    } else {
      return {
        status: "error",
        message: "Falha ao sincronizar contatos"
      };
    }
  } catch (error) {
    console.error("Erro ao sincronizar contatos Z-API:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao sincronizar contatos"
    };
  }
}

/**
 * Verifica o status da conexão com o WhatsApp
 * @param channel Canal configurado
 * @returns Status da conexão
 */
export async function checkConnectionStatus(channel: Channel): Promise<{ status: string; message?: string; connected?: boolean }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    console.log(`[Z-API] Verificando status da conexão: ${instanceId}`);
    
    // Headers atualizados conforme documentação
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    console.log(`[Z-API] Headers para verificação de status:`, JSON.stringify(headers));
    
    // Verificar status
    const response = await axios.get(
      `${BASE_URL}/instances/${instanceId}/token/${token}/status`,
      { 
        headers,
        // Configurar para validar apenas respostas de sucesso
        validateStatus: function (status) {
          return status >= 200 && status < 300; // Aceitar apenas status 2xx
        },
        // Timeout para evitar esperas muito longas
        timeout: 10000
      }
    );
    
    if (response.data) {
      console.log(`[Z-API] Resposta de status:`, JSON.stringify(response.data));
      
      // Verificar se está conectado - na Z-API, um smartphone conectado é o que indica
      // que o WhatsApp está realmente conectado, não apenas a instância
      const isConnected = response.data.connected === true && 
                          response.data.smartphoneConnected === true;
      
      return {
        status: isConnected ? "connected" : "disconnected",
        connected: isConnected,
        message: isConnected ? "WhatsApp conectado" : "WhatsApp desconectado"
      };
    } else {
      return {
        status: "error",
        message: "Não foi possível verificar o status da conexão"
      };
    }
  } catch (error) {
    console.error("[Z-API] Erro ao verificar status:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao verificar status"
    };
  }
}

/**
 * Obtém o QR Code para conexão de um canal Z-API com o WhatsApp
 * @param channel Canal Z-API configurado
 * @returns Objeto com status e QR Code em base64 (se disponível)
 */
export async function getQRCodeForChannel(channel: Channel): Promise<{ status: string; message?: string; qrCode?: string }> {
  try {
    console.log("================= OBTENDO QR CODE PARA CANAL =================");
    console.log(`Canal ID: ${channel.id}`);
    console.log(`Canal Nome: ${channel.name}`);
    console.log(`Canal Tipo: ${channel.type}`);

    // Usar valores globais conhecidos que funcionam
    const instanceId = ZAPI_INSTANCE_ID;
    const token = ZAPI_TOKEN;
    const clientToken = ZAPI_CLIENT_TOKEN;
    
    // Log dos valores utilizados para diagnóstico
    console.log("Credenciais Z-API usadas:");
    console.log(`Instance ID: ${instanceId}`);
    console.log(`Token: ${token}`);
    console.log(`Client-Token: ${clientToken.substring(0, 5)}...${clientToken.substring(clientToken.length - 5)}`);
    
    if (!instanceId || !token || !clientToken) {
      console.error("Credenciais Z-API não configuradas completamente");
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas completamente"
      };
    }
    
    // Estrutura do header exatamente como esperado pela Z-API (com C e T maiúsculos em Client-Token)
    const headers = {
      'Content-Type': 'application/json',
      'Accept': 'image/png,application/json',
      'Client-Token': clientToken
    };
    
    console.log(`Headers a serem utilizados:`, JSON.stringify(headers));
    console.log(`URL a ser chamada: ${BASE_URL}/instances/${instanceId}/token/${token}/qr-code`);
    
    try {
      console.log("Solicitando QR code diretamente...");
      
      const qrResponse = await axios.get(
        `${BASE_URL}/instances/${instanceId}/token/${token}/qr-code`,
        { 
          headers,
          responseType: 'arraybuffer',
          // Configurar para validar apenas respostas de sucesso
          validateStatus: function (status) {
            return status >= 200 && status < 300; // Aceitar apenas status 2xx
          },
          // Timeout para evitar esperas muito longas
          timeout: 10000 
        }
      );
      
      console.log("Resposta da API /qr-code recebida com status:", qrResponse.status);
      
      // Se temos dados na resposta
      if (qrResponse.data && qrResponse.data.length > 0) {
        console.log(`Recebido buffer de tamanho: ${qrResponse.data.length} bytes`);
        
        try {
          // A Z-API está retornando um objeto JSON em vez de uma imagem direta
          // Primeiro, vamos converter para texto e verificar a estrutura
          const responseText = Buffer.from(qrResponse.data).toString('utf-8');
          console.log("Primeiros 100 caracteres da resposta:", responseText.substring(0, 100) + "...");
          
          // Tentar converter para JSON
          let qrObject;
          try {
            qrObject = JSON.parse(responseText);
            console.log("Formato da resposta JSON:", Object.keys(qrObject).join(", "));
          } catch (jsonError) {
            console.log("Resposta não é um JSON válido, tratando como imagem direta");
            // Se não for JSON, vamos criar a string base64 direto da imagem
            const qrCodeBase64Direct = `data:image/png;base64,${Buffer.from(qrResponse.data).toString('base64')}`;
            
            return {
              status: "waiting_scan",
              message: "Escaneie o QR Code com o WhatsApp para conectar",
              qrCode: qrCodeBase64Direct
            };
          }
          
          // Se o objeto possui a propriedade 'connected': true, então já está conectado
          if (qrObject && qrObject.connected === true) {
            console.log("Instância já está conectada ao WhatsApp");
            return {
              status: "connected",
              message: "O WhatsApp já está conectado a esta instância"
            };
          }
          
          // Se temos um objeto JSON com a propriedade 'value', é o caso que estamos encontrando
          if (qrObject && qrObject.value) {
            console.log("QR Code retornado como JSON com propriedade 'value'");
            console.log("Valor recebido para QR code:", qrObject.value);
            
            // Retornar o valor diretamente em vez de uma URL, já que o handler vai processar
            return {
              status: "waiting_scan",
              message: "Escaneie o QR Code com o WhatsApp para conectar",
              qrCode: qrObject.value
            };
          } else {
            console.log("QR Code em formato não reconhecido:", Object.keys(qrObject).join(", "));
            // Fallback para a abordagem anterior
            const qrCodeBase64Fallback = `data:image/png;base64,${Buffer.from(qrResponse.data).toString('base64')}`;
            
            return {
              status: "waiting_scan",
              message: "Escaneie o QR Code com o WhatsApp para conectar",
              qrCode: qrCodeBase64Fallback
            };
          }
        } catch (error) {
          console.error("Erro no processamento do QR code:", error);
          // Fallback para o método original em caso de erro no processamento
          const qrCodeBase64Fallback = `data:image/png;base64,${Buffer.from(qrResponse.data).toString('base64')}`;
          
          return {
            status: "waiting_scan", 
            message: "Escaneie o QR Code com o WhatsApp para conectar (processamento alternativo)",
            qrCode: qrCodeBase64Fallback
          };
        }
      } 
      
      // Retornar erro se não conseguiu obter o QR code
      console.error("QR Code retornou dados vazios");
      return {
        status: "error",
        message: "Falha ao gerar QR Code para conexão: resposta vazia"
      };
      
    } catch (qrError) {
      console.error("Erro ao solicitar QR Code:", qrError);
      
      // Log detalhado do erro para diagnóstico
      if (axios.isAxiosError(qrError)) {
        const status = qrError.response?.status;
        const headers = qrError.response?.headers;
        const data = qrError.response?.data;
        
        console.error(`Status da resposta: ${status}`);
        
        if (data) {
          try {
            // Tentar extrair informações do erro
            const dataStr = Buffer.isBuffer(data) 
              ? Buffer.from(data).toString() 
              : typeof data === 'object'
                ? JSON.stringify(data)
                : String(data);
            
            console.error(`Dados da resposta: ${dataStr.substring(0, 300)}...`);
          } catch (convErr) {
            console.error("Não foi possível converter os dados da resposta");
          }
        }
      }
      
      return {
        status: "error",
        message: qrError instanceof Error 
          ? `Falha ao solicitar QR Code: ${qrError.message}` 
          : "Erro desconhecido ao solicitar QR Code"
      };
    }
  } catch (error) {
    console.error("Erro geral na obtenção do QR Code:", error);
    return {
      status: "error",
      message: error instanceof Error 
        ? `Erro geral na obtenção do QR Code: ${error.message}` 
        : "Erro desconhecido na obtenção do QR Code"
    };
  }
}

/**
 * Desconecta a sessão do WhatsApp
 * @param channel Canal configurado
 * @returns Status da operação
 */
export async function disconnectSession(channel: Channel): Promise<{ status: string; message?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Headers atualizados conforme documentação
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    console.log(`[Z-API] Desconectando sessão para instância ${instanceId}`);
    console.log(`[Z-API] Headers para desconexão:`, JSON.stringify(headers));
    
    // Desconectar sessão
    const response = await axios.get(
      `${BASE_URL}/instances/${instanceId}/token/${token}/disconnect`,
      { headers }
    );
    
    console.log(`[Z-API] Resposta da desconexão:`, JSON.stringify(response.data, null, 2));
    
    return {
      status: "success",
      message: "Sessão desconectada com sucesso"
    };
  } catch (error) {
    console.error("[Z-API] Erro ao desconectar sessão:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao desconectar sessão"
    };
  }
}

/**
 * Reinicia a sessão do WhatsApp
 * @param channel Canal configurado
 * @returns Status da operação
 */
export async function restartSession(channel: Channel): Promise<{ status: string; message?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Headers atualizados conforme documentação
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    console.log(`[Z-API] Reiniciando sessão para instância ${instanceId}`);
    console.log(`[Z-API] Headers para reinicialização:`, JSON.stringify(headers));
    
    // Reiniciar sessão
    const response = await axios.get(
      `${BASE_URL}/instances/${instanceId}/token/${token}/restart`,
      { headers }
    );
    
    console.log(`[Z-API] Resposta da reinicialização:`, JSON.stringify(response.data, null, 2));
    
    return {
      status: "success",
      message: "Sessão reiniciada com sucesso. Aguarde alguns segundos e reconecte com QR Code."
    };
  } catch (error) {
    console.error("[Z-API] Erro ao reiniciar sessão:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao reiniciar sessão"
    };
  }
}

/**
 * Verifica o status do webhook configurado para um canal
 * @param channel Canal a ser verificado
 * @returns Objeto com status da verificação
 */
export async function checkWebhookStatus(channel: Channel): Promise<{ 
  status: string; 
  message?: string; 
  configured?: boolean;
  webhookUrl?: string;
  webhookFeatures?: {
    receiveAllNotifications?: boolean;
    messageReceived?: boolean;
    messageCreate?: boolean;
    statusChange?: boolean;
    presenceChange?: boolean;
    deviceConnected?: boolean;
    receiveByEmail?: boolean;
  };
}> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    console.log(`[Z-API] Verificando status do webhook para canal ${channel.id} (instância ${instanceId})...`);
    
    // Determinar a URL correta do webhook com base nas informações do canal
    let baseUrl = '';
    if (process.env.APP_URL) {
      baseUrl = process.env.APP_URL;
    } else if (process.env.REPLIT_DOMAINS) {
      baseUrl = `https://${process.env.REPLIT_DOMAINS.split(',')[0]}`;
    } else {
      baseUrl = 'https://0eb8be2b-04a6-47e5-bbf1-dd3bd83018b0-00-2m0jsmtd34bj0.picard.replit.dev';
    }
    
    // URL esperada do webhook (deve corresponder à URL configurada)
    const expectedWebhookUrl = `${baseUrl}/api/webhooks/zapi/${channel.id}`;
    
    try {
      // CORREÇÃO IMPORTANTE: Se o webhook estiver configurado nos metadados do canal,
      // vamos considerar que está configurado sem precisar verificar na API.
      // Isso evita problemas com verificações que falham na API mas o webhook está funcionando
      if (channel.metadata && 
          channel.metadata.webhookConfigured === true && 
          channel.metadata.webhookUrl) {
        
        console.log(`[Z-API] Usando dados armazenados para canal ${channel.id}: webhook configurado para ${channel.metadata.webhookUrl}`);
        
        // Usar os dados que temos armazenados para retorno
        return {
          status: "success",
          configured: true,
          webhookUrl: channel.metadata.webhookUrl,
          webhookFeatures: channel.metadata.webhookFeatures || {
            receiveAllNotifications: true,
            messageReceived: true,
            messageCreate: true,
            statusChange: true,
            presenceChange: true, 
            deviceConnected: true,
            receiveByEmail: false
          },
          message: `Webhook configurado para: ${channel.metadata.webhookUrl} (dados armazenados)`
        };
      }
      
      // Se não temos metadados ou precisamos atualizar, tentamos verificar na API
      const headers = getHeadersWithToken(token, ZAPI_CLIENT_TOKEN);
      
      console.log(`[Z-API] Headers configurados: ${JSON.stringify(headers, null, 2)}`);
      console.log(`[Z-API] Fazendo requisição GET para ${BASE_URL}/instances/${instanceId}/token/${token}/webhook`);
      
      try {
        const response = await axios.get(
          `${BASE_URL}/instances/${instanceId}/token/${token}/webhook`,
          { headers }
        );
        
        console.log(`[Z-API] Resposta da verificação de webhook:`, JSON.stringify(response.data, null, 2));
        
        // Compatibilidade com todas as versões da API Z-API (nova e antiga)
        // A API mais recente retorna objeto com 'url', a antiga retorna objeto com 'value'
        // Algumas versões podem retornar diretamente a string da URL
        let webhookUrl = null;
        if (typeof response.data === 'string' && response.data.startsWith('http')) {
          // Caso 1: Resposta é diretamente a URL como string
          webhookUrl = response.data;
        } else if (response.data?.url) {
          // Caso 2: Resposta tem formato { url: "https://..." }
          webhookUrl = response.data.url;
        } else if (response.data?.value && typeof response.data.value === 'string') {
          // Caso 3: Resposta tem formato { value: "https://..." }
          webhookUrl = response.data.value;
        }
        
        const isConfigured = !!webhookUrl && webhookUrl.length > 0;
        
        // Extrair features do webhook se existirem
        // API nova: webhookFeatures é um objeto com propriedades booleanas
        // API antiga: pode não ter essas propriedades
        const webhookFeatures = response.data?.webhookFeatures || {};
        
        return {
          status: "success",
          configured: isConfigured,
          webhookUrl: webhookUrl,
          webhookFeatures: {
            receiveAllNotifications: webhookFeatures.receiveAllNotifications || false,
            messageReceived: webhookFeatures.messageReceived || false,
            messageCreate: webhookFeatures.messageCreate || false,
            statusChange: webhookFeatures.statusChange || false,
            presenceChange: webhookFeatures.presenceChange || false,
            deviceConnected: webhookFeatures.deviceConnected || false,
            receiveByEmail: webhookFeatures.receiveByEmail || false
          },
          message: isConfigured 
            ? `Webhook configurado para: ${webhookUrl}` 
            : 'Webhook não configurado'
        };
      } catch (error) {
        console.log(`[Z-API] Erro esperado ao verificar webhook (método GET):`, error.message);
        
        // Verificar se o webhook foi configurado nos metadados do canal
        if (channel.metadata && channel.metadata.webhookConfigured === true) {
          console.log(`[Z-API] Webhook está configurado de acordo com os metadados do canal`);
          
          // Retornar as informações salvas nos metadados
          return {
            status: "success",
            configured: true,
            webhookUrl: expectedWebhookUrl,
            webhookFeatures: {
              receiveAllNotifications: true,
              messageReceived: true,
              messageCreate: true,
              statusChange: true,
              presenceChange: true,
              deviceConnected: true,
              receiveByEmail: false
            },
            message: `Webhook configurado para: ${expectedWebhookUrl}`
          };
        }
        
        // Vamos verificar o status da instância como alternativa
        console.log(`[Z-API] Método alternativo: verificar status da instância...`);
        
        try {
          const connectionStatus = await checkConnectionStatus(channel);
          
          if (connectionStatus.status === "success" && connectionStatus.connected) {
            // Se a instância está conectada, provavelmente o webhook funciona também
            // mas a API não está retornando o status corretamente
            console.log(`[Z-API] Instância está conectada, assumindo que o webhook está configurado`);
            
            return {
              status: "success",
              configured: true,
              webhookUrl: expectedWebhookUrl,
              webhookFeatures: {
                receiveAllNotifications: true,
                messageReceived: true,
                messageCreate: true,
                statusChange: true,
                presenceChange: true,
                deviceConnected: true,
                receiveByEmail: false
              },
              message: `Webhook assumido como configurado (instância conectada)`
            };
          }
        } catch (statusError) {
          console.error("[Z-API] Erro ao verificar status alternativo:", statusError);
        }
        
        // Se chegamos aqui, realmente o webhook não está configurado
        return {
          status: "success",
          configured: false,
          webhookUrl: null,
          webhookFeatures: {
            receiveAllNotifications: false,
            messageReceived: false,
            messageCreate: false,
            statusChange: false,
            presenceChange: false,
            deviceConnected: false,
            receiveByEmail: false
          },
          message: "Webhook não configurado"
        };
      }
    } catch (error) {
      console.error("[Z-API] Erro ao verificar webhook:", error);
      
      let errorMessage = "Erro desconhecido ao verificar webhook";
      if (axios.isAxiosError(error)) {
        const responseData = error.response?.data;
        errorMessage = responseData?.error || responseData?.message || error.message;
        console.error("[Z-API] Detalhes da resposta:", JSON.stringify(error.response?.data, null, 2));
      } else if (error instanceof Error) {
        errorMessage = error.message;
      }
      
      return {
        status: "error",
        configured: false,
        message: errorMessage
      };
    }
  } catch (error) {
    console.error("[Z-API] Erro ao verificar webhook:", error);
    
    let errorMessage = "Erro desconhecido ao verificar webhook";
    if (axios.isAxiosError(error)) {
      const responseData = error.response?.data;
      errorMessage = responseData?.error || responseData?.message || error.message;
      console.error("[Z-API] Detalhes da resposta:", JSON.stringify(error.response?.data, null, 2));
    } else if (error instanceof Error) {
      errorMessage = error.message;
    }
    
    return {
      status: "error",
      configured: false,
      message: errorMessage
    };
  }
}

/**
 * Configura o webhook para recebimento de mensagens em um canal
 * @param channel Canal a ser configurado
 * @param webhookUrl URL opcional do webhook (senão, será usada a URL padrão do sistema)
 * @param webhookFeatures Configurações específicas de recursos do webhook
 * @returns Objeto com status da configuração
 */
/**
 * Marca uma mensagem como lida no WhatsApp
 * @param channel Canal configurado
 * @param messageId ID da mensagem a ser marcada como lida
 * @returns Status da operação
 */
export async function markMessageAsRead(
  channel: Channel,
  messageId: string
): Promise<{ status: string; message?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Marcando mensagem como lida na Z-API
    console.log(`[Z-API] Marcando mensagem ${messageId} como lida`);
    
    // Endpoint da API Z-API para marcar como lida
    const response = await axios.post(
      `${BASE_URL}/instances/${instanceId}/token/${token}/read-message`,
      {
        messageId
      },
      {
        headers: getHeadersWithToken(token)
      }
    );
    
    // Verificar resposta
    if (response.data && response.data.success) {
      return {
        status: "success",
        message: "Mensagem marcada como lida com sucesso"
      };
    } else {
      return {
        status: "error",
        message: "Falha ao marcar mensagem como lida"
      };
    }
  } catch (error) {
    console.error("Erro ao marcar mensagem como lida na Z-API:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao marcar mensagem como lida"
    };
  }
}

export async function configureWebhook(
  channel: Channel, 
  webhookUrl?: string,
  webhookFeatures?: {
    receiveAllNotifications?: boolean;
    messageReceived?: boolean;
    messageCreate?: boolean;
    statusChange?: boolean;
    presenceChange?: boolean;
    deviceConnected?: boolean;
    receiveByEmail?: boolean;
  }
): Promise<{ status: string; message?: string; configured?: boolean; webhookUrl?: string; webhookFeatures?: any }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      console.log(`[Z-API] Erro: Credenciais não configuradas para canal ${channel.id}`);
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Determinar a URL base da aplicação
    let baseUrl = '';
    if (process.env.APP_URL) {
      baseUrl = process.env.APP_URL;
    } else if (process.env.REPLIT_DOMAINS) {
      baseUrl = `https://${process.env.REPLIT_DOMAINS.split(',')[0]}`;
    } else {
      // URL da Replit atual baseada na ID do projeto
      baseUrl = 'https://0eb8be2b-04a6-47e5-bbf1-dd3bd83018b0-00-2m0jsmtd34bj0.picard.replit.dev';
    }
    
    // URL do webhook - garantindo que seja uma URL acessível externamente
    // e inclui o ID do canal para roteamento correto
    const finalWebhookUrl = webhookUrl || `${baseUrl}/api/webhooks/zapi/${channel.id}`;
    
    // Extrair features individuais para campos separados de acordo com a interface mostrada
    const features = webhookFeatures || {
      receiveAllNotifications: true,
      messageReceived: true,
      messageCreate: true,
      statusChange: true, 
      deviceConnected: true
    };
    
    console.log(`[Z-API] Configurando webhook para canal ${channel.id}:`);
    console.log(`[Z-API] URL do webhook: ${finalWebhookUrl}`);
    console.log(`[Z-API] Instância: ${instanceId}`);
    
    // Headers com o Client-Token correto - isso é fundamental para autenticação na API
    const headers = getHeadersWithToken(token, clientToken);
    console.log(`[Z-API] Headers para configuração do webhook:`, JSON.stringify(headers, null, 2));
    
    // Configurar o webhook na Z-API usando os endpoints conforme a documentação atual
    let webhookConfigured = false;
    let configError = null;
    
    // === CONFIGURAÇÃO PRINCIPAL: Configurar o Webhook usando API mais recente ===
    // De acordo com a documentação atual da Z-API: webhook unificado
    try {
      console.log(`[Z-API] Configurando webhook usando a API unificada...`);
      
      // Configurar o webhook usando o endpoint e método atual
      const webhookConfig = {
        url: finalWebhookUrl,
        webhookFeatures: {
          receiveAllNotifications: features.receiveAllNotifications || true,
          messageReceived: features.messageReceived || true,
          messageCreate: features.messageCreate || true,
          statusChange: features.statusChange || true,
          presenceChange: features.presenceChange || true,
          deviceConnected: features.deviceConnected || true,
          receiveByEmail: features.receiveByEmail || false
        }
      };
      
      console.log(`[Z-API] Payload de configuração do webhook:`, JSON.stringify(webhookConfig, null, 2));
      
      // Usando método PUT em vez de POST como recomendado pela documentação mais recente
      const webhookResponse = await axios.put(
        `${BASE_URL}/instances/${instanceId}/token/${token}/webhook`,
        webhookConfig,
        { headers }
      );
      
      console.log(`[Z-API] Resposta da configuração do Webhook:`, 
        JSON.stringify(webhookResponse.data, null, 2));
      
      webhookConfigured = true;
    } catch (error) {
      if (error instanceof Error) {
        console.log("[Z-API] Erro na configuração do webhook via API unificada:", error.message);
        if (axios.isAxiosError(error)) {
          console.log("[Z-API] Detalhes do erro:", JSON.stringify(error.response?.data, null, 2));
          
          // Como estamos usando a API mais recente, tentar alternativa em caso de falha
          configError = error;
        }
      }
    }
    
    // Não precisamos mais das etapas adicionais 2, 3, 4 já que a nova API configura tudo em uma única chamada
    // Se a primeira chamada falhar, tentaremos um método alternativo (fallback)
    if (!webhookConfigured) {
      try {
        console.log(`[Z-API] Tentativa alternativa: Configurando webhook usando método legado...`);
        
        // Tentar configurar usando endpoint de webhook simples (método alternativo)
        const fallbackResponse = await axios.post(
          `${BASE_URL}/instances/${instanceId}/token/${token}/webhook`,
          {
            url: finalWebhookUrl,
            // Incluir opções mais simples para versões mais antigas da API
            enabled: true,
            messageTypes: ["all"]
          },
          { headers }
        );
        
        console.log(`[Z-API] Resposta da configuração alternativa de Webhook:`, 
          JSON.stringify(fallbackResponse.data, null, 2));
        
        // Se chegamos aqui, a configuração foi bem-sucedida
        webhookConfigured = true;
      } catch (fallbackError) {
        if (fallbackError instanceof Error) {
          console.log("[Z-API] Erro na configuração alternativa de webhook:", fallbackError.message);
          // Não definimos configError aqui para tentar ainda outro método se necessário
        }
      }
    }
    
    // MELHORIA: Atualizar metadados do canal para armazenar o status da configuração
    // Isso garante que mesmo que a API Z-API retorne erros na verificação do webhook,
    // ainda teremos informações persistentes no banco de dados sobre a configuração
    try {
      // Importar db para atualizar o canal
      const { db } = await import("../../../db");
      const { channels } = await import("../../../shared/schema");
      const { eq } = await import("drizzle-orm");
      
      // Obter canal atualizado para ter metadados atuais
      const [currentChannel] = await db.select()
        .from(channels)
        .where(eq(channels.id, channel.id));
      
      // Preparar metadados com informações de webhook
      const metadata = {
        ...(currentChannel?.metadata || {}),
        webhookConfigured: true,
        webhookUrl: finalWebhookUrl,
        webhookFeatures: features,
        lastWebhookSetup: new Date().toISOString(),
        lastSuccessfulConfiguration: new Date().toISOString(),
        // Garantir que os dados abaixo não sejam perdidos caso já existam
        webhookReceiveCount: currentChannel?.metadata?.webhookReceiveCount || 0,
        lastWebhookReceived: currentChannel?.metadata?.lastWebhookReceived || null,
        webhookConfigurationMethod: webhookConfigured ? 
          (currentChannel?.metadata?.webhookConfigurationMethod || "api") + "+db" : 
          "db_only"
      };
      
      // Atualizar o canal com a informação de webhook configurado
      await db.update(channels)
        .set({ metadata })
        .where(eq(channels.id, channel.id));
      
      console.log(`[Z-API] Metadados do canal atualizados com informações do webhook:`, 
        JSON.stringify(metadata, null, 2));
    } catch (dbError) {
      if (dbError instanceof Error) {
        console.error("[Z-API] Erro ao atualizar metadados do canal:", dbError.message);
      }
      // Continuamos mesmo com erro de DB, não é crítico
    }
    
    // Se não conseguimos configurar o webhook com nenhum método, retorna erro
    if (!webhookConfigured && configError) {
      return {
        status: "error",
        configured: false,
        message: `Falha ao configurar webhook: ${configError instanceof Error ? configError.message : "Erro desconhecido"}`
      };
    }
    
    return {
      status: "success",
      configured: true,
      webhookUrl: finalWebhookUrl,
      webhookFeatures: features,
      message: `Webhook configurado com sucesso para: ${finalWebhookUrl}`
    };
    
  } catch (error) {
    console.error("[Z-API] Erro ao configurar webhook:", error);
    let errorDetails = "Erro desconhecido ao configurar webhook";
    
    if (axios.isAxiosError(error)) {
      const responseData = error.response?.data;
      if (responseData) {
        errorDetails = responseData.error || responseData.message || error.message;
      } else {
        errorDetails = error.message;
      }
      console.error("[Z-API] Detalhes da resposta:", JSON.stringify(error.response?.data, null, 2));
    } else if (error instanceof Error) {
      errorDetails = error.message;
    }
    
    return {
      status: "error",
      configured: false,
      message: errorDetails
    };
  }
}

/**
 * Envia uma mensagem de teste para uma conversa na caixa de entrada
 * @param channel Canal para enviar a mensagem
 * @returns Objeto com status do envio
 */
/**
 * Envia uma mensagem de link via Z-API
 * @param channel Canal configurado
 * @param to Número de telefone de destino
 * @param linkUrl URL do link a ser enviado
 * @param title Título opcional para o link (preview)
 * @param description Descrição opcional para o link (preview)
 * @returns Status do envio com ID da mensagem
 */
/**
 * Envia uma mensagem com botões via Z-API
 * @param channel Canal configurado
 * @param to Número de telefone de destino
 * @param title Título da mensagem com botões (obrigatório)
 * @param message Texto da mensagem principal
 * @param buttons Array de botões com texto (de 1 a 3 botões)
 * @param footer Texto de rodapé (opcional)
 * @returns Status do envio com ID da mensagem
 */
export async function sendButtonMessage(
  channel: Channel,
  to: string,
  title: string,
  message: string,
  buttons: Array<{text: string}>,
  footer?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    // Verificar obrigatórios
    if (!channel || !channel.config) {
      return {
        status: "error",
        message: "Configuração do canal inválida"
      };
    }

    if (!to) {
      return {
        status: "error",
        message: "Número de destino obrigatório para mensagens com botões"
      };
    }

    if (!title || !message) {
      return {
        status: "error",
        message: "Título e mensagem obrigatórios para envio com botões"
      };
    }

    if (!buttons || buttons.length < 1 || buttons.length > 3) {
      return {
        status: "error",
        message: "É necessário fornecer de 1 a 3 botões"
      };
    }

    // Extrair configurações do canal
    const provider = channel.config.provider as string;
    if (provider !== "zapi") {
      return {
        status: "error",
        message: "Canal não é Z-API"
      };
    }

    const instanceId = channel.config.instanceId as string;
    const token = channel.config.token as string;
    const clientToken = ZAPI_CLIENT_TOKEN;

    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas corretamente"
      };
    }

    // Formatação correta do número do WhatsApp
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    // Verificar se o número é um grupo
    const isGroup = to.includes('-group') || to.includes('@g.us');
    
    // Se for um grupo, precisamos usar o ID do grupo sem formatação
    if (isGroup) {
      formattedPhone = to;
      console.log(`[Z-API] Detectado grupo: ${formattedPhone}`);
    } else {
      console.log(`[Z-API] Enviando mensagem com botões para: ${formattedPhone} (original: ${to})`);
    }
    
    // Headers completos para requisição
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de mensagem com botões conforme documentação mais recente
    // Usamos send-button-list conforme a documentação enviada pelo usuário
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-button-list`;
    
    // Transformar o formato de botões para o formato esperado pela API
    const formattedButtons = formatButtonsForZAPI(buttons);
    
    // Payload no formato correto para send-button-list conforme documentação Z-API
    // https://developer.z-api.io/message/send-button-list
    const payload = {
      phone: formattedPhone,
      message: message, // Texto principal
      buttonText: "Clique aqui", // Texto do botão que exibe a lista (obrigatório)
      title: title,     // Título da lista de botões
      footer: footer || "",
      buttons: formattedButtons
    };
    
    console.log("[Z-API] Enviando mensagem com botões:", JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    // Verificar resposta da API
    if (response.data && response.data.id) {
      return {
        status: "success",
        message: "Mensagem com botões enviada com sucesso",
        messageId: response.data.id
      };
    } else if (response.data && response.data.messageId) {
      return {
        status: "success",
        message: "Mensagem com botões enviada com sucesso",
        messageId: response.data.messageId
      };
    } else if (response.data && response.data.zaapId) {
      return {
        status: "success",
        message: "Mensagem com botões enviada com sucesso",
        messageId: response.data.zaapId
      };
    } else {
      console.error("[Z-API] Resposta sem ID da mensagem:", response.data);
      return {
        status: "warning",
        message: "Mensagem enviada, mas ID não retornado"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar mensagem com botões:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.message || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar mensagem com botões"
    };
  }
}

/**
 * Envia uma mensagem com botões e imagem via Z-API
 * @param channel Canal configurado
 * @param to Número de telefone de destino
 * @param title Título da mensagem com botões (obrigatório)
 * @param message Texto da mensagem principal
 * @param buttons Array de botões com texto (de 1 a 3 botões)
 * @param imageUrl URL da imagem a ser exibida
 * @param footer Texto de rodapé (opcional)
 * @returns Status do envio com ID da mensagem
 */
export async function sendButtonImageMessage(
  channel: Channel,
  to: string,
  title: string,
  message: string,
  buttons: Array<{text: string}>,
  imageUrl: string,
  footer?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    // Verificar obrigatórios
    if (!channel || !channel.config) {
      return {
        status: "error",
        message: "Configuração do canal inválida"
      };
    }

    if (!to) {
      return {
        status: "error",
        message: "Número de destino obrigatório para mensagens com botões e imagem"
      };
    }

    if (!title || !message) {
      return {
        status: "error",
        message: "Título e mensagem obrigatórios para envio com botões e imagem"
      };
    }

    if (!buttons || buttons.length < 1 || buttons.length > 3) {
      return {
        status: "error",
        message: "É necessário fornecer de 1 a 3 botões"
      };
    }

    if (!imageUrl) {
      return {
        status: "error",
        message: "URL da imagem obrigatória para mensagens com botões e imagem"
      };
    }

    // Extrair configurações do canal
    const provider = channel.config.provider as string;
    if (provider !== "zapi") {
      return {
        status: "error",
        message: "Canal não é Z-API"
      };
    }

    const instanceId = channel.config.instanceId as string;
    const token = channel.config.token as string;
    const clientToken = ZAPI_CLIENT_TOKEN;

    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas corretamente"
      };
    }

    // Formatação correta do número do WhatsApp
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    // Verificar se o número é um grupo
    const isGroup = to.includes('-group') || to.includes('@g.us');
    
    // Se for um grupo, precisamos usar o ID do grupo sem formatação
    if (isGroup) {
      formattedPhone = to;
      console.log(`[Z-API] Detectado grupo: ${formattedPhone}`);
    } else {
      console.log(`[Z-API] Enviando mensagem com botões e imagem para: ${formattedPhone} (original: ${to})`);
    }
    
    // Headers completos para requisição
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de mensagem com botões e imagem conforme documentação mais recente
    // Usamos send-button-list-image conforme a documentação
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-button-list-image`;
    
    // Verificar se é base64 ou URL
    const isBase64Image = imageUrl.startsWith('data:');
    
    // Transformar o formato de botões para o formato esperado pela API
    const formattedButtons = formatButtonsForZAPI(buttons);
    
    // Payload no formato correto conforme documentação Z-API para send-button-list-image
    const payload = {
      phone: formattedPhone,
      image: imageUrl, // URL ou base64 da imagem
      message: message, // Texto principal
      // Usando o formato oficial conforme a documentação
      title: title,     // Título explícito  
      footer: footer || "",
      buttons: formattedButtons // Botões no formato correto
    };
    
    console.log(`[Z-API] Enviando mensagem com botões e imagem (${isBase64Image ? 'Base64' : 'URL'}):`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    // Verificar resposta da API
    if (response.data && response.data.id) {
      return {
        status: "success",
        message: "Mensagem com botões e imagem enviada com sucesso",
        messageId: response.data.id
      };
    } else if (response.data && response.data.messageId) {
      return {
        status: "success",
        message: "Mensagem com botões e imagem enviada com sucesso",
        messageId: response.data.messageId
      };
    } else if (response.data && response.data.zaapId) {
      return {
        status: "success",
        message: "Mensagem com botões e imagem enviada com sucesso",
        messageId: response.data.zaapId
      };
    } else {
      console.error("[Z-API] Resposta sem ID da mensagem:", response.data);
      return {
        status: "warning",
        message: "Mensagem enviada, mas ID não retornado"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar mensagem com botões e imagem:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.message || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar mensagem com botões e imagem"
    };
  }
}

/**
 * Envia uma mensagem com botões e vídeo via Z-API
 * @param channel Canal configurado
 * @param to Número de telefone de destino
 * @param title Título da mensagem com botões (obrigatório)
 * @param message Texto da mensagem principal
 * @param buttons Array de botões com texto (de 1 a 3 botões)
 * @param videoUrl URL do vídeo a ser exibido
 * @param footer Texto de rodapé (opcional)
 * @returns Status do envio com ID da mensagem
 */
export async function sendButtonVideoMessage(
  channel: Channel,
  to: string,
  title: string,
  message: string,
  buttons: Array<{text: string}>,
  videoUrl: string,
  footer?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    // Verificar obrigatórios
    if (!channel || !channel.config) {
      return {
        status: "error",
        message: "Configuração do canal inválida"
      };
    }

    if (!to) {
      return {
        status: "error",
        message: "Número de destino obrigatório para mensagens com botões e vídeo"
      };
    }

    if (!title || !message) {
      return {
        status: "error",
        message: "Título e mensagem obrigatórios para envio com botões e vídeo"
      };
    }

    if (!buttons || buttons.length < 1 || buttons.length > 3) {
      return {
        status: "error",
        message: "É necessário fornecer de 1 a 3 botões"
      };
    }

    if (!videoUrl) {
      return {
        status: "error",
        message: "URL do vídeo obrigatória para mensagens com botões e vídeo"
      };
    }

    // Extrair configurações do canal
    const provider = channel.config.provider as string;
    if (provider !== "zapi") {
      return {
        status: "error",
        message: "Canal não é Z-API"
      };
    }

    const instanceId = channel.config.instanceId as string;
    const token = channel.config.token as string;
    const clientToken = ZAPI_CLIENT_TOKEN;

    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas corretamente"
      };
    }

    // Formatação correta do número do WhatsApp
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    // Verificar se o número é um grupo
    const isGroup = to.includes('-group') || to.includes('@g.us');
    
    // Se for um grupo, precisamos usar o ID do grupo sem formatação
    if (isGroup) {
      formattedPhone = to;
      console.log(`[Z-API] Detectado grupo: ${formattedPhone}`);
    } else {
      console.log(`[Z-API] Enviando mensagem com botões e vídeo para: ${formattedPhone} (original: ${to})`);
    }
    
    // Headers completos para requisição
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de mensagem com botões e vídeo conforme documentação mais recente
    // Usamos send-button-list-video conforme a documentação
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-button-list-video`;
    
    // Verificar se é base64 ou URL
    const isBase64Video = videoUrl.startsWith('data:');
    
    // Transformar o formato de botões para o formato esperado pela API
    const formattedButtons = formatButtonsForZAPI(buttons);
    
    // Payload no formato correto conforme documentação Z-API para send-button-list-video
    const payload = {
      phone: formattedPhone,
      video: videoUrl, // URL ou base64 do vídeo
      message: message, // Texto principal
      // Usando o formato oficial conforme a documentação
      title: title,     // Título explícito  
      footer: footer || "",
      buttons: formattedButtons // Botões no formato correto
    };
    
    console.log(`[Z-API] Enviando mensagem com botões e vídeo (${isBase64Video ? 'Base64' : 'URL'}):`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    // Verificar resposta da API
    if (response.data && response.data.id) {
      return {
        status: "success",
        message: "Mensagem com botões e vídeo enviada com sucesso",
        messageId: response.data.id
      };
    } else if (response.data && response.data.messageId) {
      return {
        status: "success",
        message: "Mensagem com botões e vídeo enviada com sucesso",
        messageId: response.data.messageId
      };
    } else if (response.data && response.data.zaapId) {
      return {
        status: "success",
        message: "Mensagem com botões e vídeo enviada com sucesso",
        messageId: response.data.zaapId
      };
    } else {
      console.error("[Z-API] Resposta sem ID da mensagem:", response.data);
      return {
        status: "warning",
        message: "Mensagem enviada, mas ID não retornado"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar mensagem com botões e vídeo:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.message || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar mensagem com botões e vídeo"
    };
  }
}

/**
 * Envia uma mensagem com lista de opções via Z-API
 * @param channel Canal configurado
 * @param to Número de telefone de destino
 * @param message Texto da mensagem
 * @param title Título da lista
 * @param buttonText Texto do botão (para abrir a lista)
 * @param sections Seções da lista com opções
 * @param footer Texto de rodapé (opcional)
 * @returns Status do envio com ID da mensagem
 */
export async function sendOptionList(
  channel: Channel,
  to: string,
  message: string,
  title: string,
  buttonText: string,
  sections: Array<{
    title: string;
    rows: Array<{
      title: string;
      description?: string;
      id: string;
    }>
  }>,
  footer?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    // Verificar obrigatórios
    if (!channel || !channel.config) {
      return {
        status: "error",
        message: "Configuração do canal inválida"
      };
    }

    if (!to) {
      return {
        status: "error",
        message: "Número de destino obrigatório para mensagens com lista de opções"
      };
    }

    if (!message || !title || !buttonText || !sections || sections.length === 0) {
      return {
        status: "error",
        message: "Mensagem, título, texto do botão e ao menos uma seção são obrigatórios"
      };
    }

    // Verificar se pelo menos uma seção tem opções
    let hasSomeOptions = false;
    for (const section of sections) {
      if (section.rows && section.rows.length > 0) {
        hasSomeOptions = true;
        break;
      }
    }

    if (!hasSomeOptions) {
      return {
        status: "error",
        message: "É necessário incluir pelo menos uma opção em alguma seção"
      };
    }

    // Extrair configurações do canal
    const provider = channel.config.provider as string;
    if (provider !== "zapi") {
      return {
        status: "error",
        message: "Canal não é Z-API"
      };
    }

    const instanceId = channel.config.instanceId as string;
    const token = channel.config.token as string;
    const clientToken = ZAPI_CLIENT_TOKEN;

    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas corretamente"
      };
    }

    // Formatação correta do número do WhatsApp
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    // Verificar se o número é um grupo
    const isGroup = to.includes('-group') || to.includes('@g.us');
    
    // Se for um grupo, precisamos usar o ID do grupo sem formatação
    if (isGroup) {
      formattedPhone = to;
      console.log(`[Z-API] Detectado grupo: ${formattedPhone}`);
    } else {
      console.log(`[Z-API] Enviando lista de opções para: ${formattedPhone} (original: ${to})`);
    }
    
    // Headers completos para requisição
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de lista de opções
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-option-list`;
    
    // Payload conforme documentação Z-API para send-option-list
    const payload = {
      phone: formattedPhone,
      message: message, // Texto principal
      title: title, // Título da lista
      buttonText: buttonText, // Texto do botão para abrir a lista
      sections: sections, // Seções com opções
      footer: footer || "" // Rodapé opcional
    };
    
    console.log("[Z-API] Enviando lista de opções:", JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    // Verificar resposta da API
    if (response.data && response.data.id) {
      return {
        status: "success",
        message: "Lista de opções enviada com sucesso",
        messageId: response.data.id
      };
    } else if (response.data && response.data.messageId) {
      return {
        status: "success",
        message: "Lista de opções enviada com sucesso",
        messageId: response.data.messageId
      };
    } else if (response.data && response.data.zaapId) {
      return {
        status: "success",
        message: "Lista de opções enviada com sucesso",
        messageId: response.data.zaapId
      };
    } else {
      console.error("[Z-API] Resposta sem ID da mensagem:", response.data);
      return {
        status: "warning",
        message: "Lista de opções enviada, mas ID não retornado"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar lista de opções:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.message || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar lista de opções"
    };
  }
}

export async function sendLinkMessage(
  channel: Channel,
  to: string,
  linkUrl: string,
  title?: string,
  description?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Formatação do número do WhatsApp conforme documentação
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API] Enviando link para ${formattedPhone} (original: ${to}): "${linkUrl}"`);
    console.log(`[Z-API] Título: "${title || 'sem título'}"`);
    console.log(`[Z-API] Descrição: "${description || 'sem descrição'}"`);
    
    // Headers completos para requisição
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de link
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-link`;
    console.log(`[Z-API] Chamando endpoint: ${endpoint}`);
    
    // Payload conforme documentação da Z-API
    const payload = {
      phone: formattedPhone,
      message: linkUrl,      // URL do link
      linkUrl: linkUrl,      // URL do link (duplicado para compatibilidade com diferentes versões da API)
      title: title || '',     // Título opcional
      description: description || ''  // Descrição opcional
    };
    
    console.log(`[Z-API] Enviando payload:`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    console.log(`[Z-API] Resposta de envio de link:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme documentação
    if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
      const messageId = response.data.messageId || response.data.id || response.data.zaapId;
      console.log(`[Z-API] Link enviado com sucesso, ID: ${messageId}`);
      return {
        status: "success",
        messageId: messageId
      };
    } else if (response.data && response.data.value === true) {
      // Algumas versões da API retornam o campo value como true para indicar sucesso
      console.log(`[Z-API] Link enviado com sucesso, resposta sem ID (usar Z-API mais recente)`);
      return {
        status: "success",
        messageId: "unknown" // Não temos ID neste caso
      };
    } else {
      console.error(`[Z-API] Resposta de erro ao enviar link:`, response.data);
      return {
        status: "error",
        message: "Falha ao enviar link via Z-API: Resposta sem ID de mensagem"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar link Z-API:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar link Z-API"
    };
  }
}

/**
 * Encaminha uma mensagem previamente enviada/recebida via Z-API
 * @param channel Canal configurado
 * @param to Número de telefone de destino
 * @param messageId ID da mensagem original a ser encaminhada
 * @returns Status do encaminhamento com ID da nova mensagem
 */
export async function forwardMessage(
  channel: Channel,
  to: string,
  messageId: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    // Formatação do número do WhatsApp conforme documentação
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o número não tiver o código do país, adiciona o código do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API] Encaminhando mensagem para ${formattedPhone} (original: ${to})`);
    console.log(`[Z-API] MessageID a ser encaminhado: ${messageId}`);
    
    // Headers completos para requisição
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para encaminhamento de mensagem
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/forward-message`;
    console.log(`[Z-API] Chamando endpoint: ${endpoint}`);
    
    // Payload conforme documentação da Z-API
    const payload = {
      phone: formattedPhone,
      messageId: messageId
    };
    
    console.log(`[Z-API] Enviando payload:`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    console.log(`[Z-API] Resposta de encaminhamento:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme documentação
    if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
      const forwardedMessageId = response.data.messageId || response.data.id || response.data.zaapId;
      console.log(`[Z-API] Mensagem encaminhada com sucesso, ID: ${forwardedMessageId}`);
      return {
        status: "success",
        messageId: forwardedMessageId
      };
    } else if (response.data && response.data.value === true) {
      // Algumas versões da API retornam o campo value como true para indicar sucesso
      console.log(`[Z-API] Mensagem encaminhada com sucesso, resposta sem ID (usar Z-API mais recente)`);
      return {
        status: "success",
        messageId: "unknown" // Não temos ID neste caso
      };
    } else {
      console.error(`[Z-API] Resposta de erro ao encaminhar mensagem:`, response.data);
      return {
        status: "error",
        message: "Falha ao encaminhar mensagem via Z-API: Resposta sem ID de mensagem"
      };
    }
  } catch (error) {
    console.error("Erro ao encaminhar mensagem via Z-API:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao encaminhar mensagem Z-API"
    };
  }
}

/**
 * Exclui uma mensagem previamente enviada via Z-API
 * @param channel Canal configurado
 * @param messageId ID da mensagem a ser excluída
 * @param phone Número de telefone opcional (necessário para alguns endpoints da Z-API)
 * @returns Status da exclusão
 */
export async function deleteMessage(
  channel: Channel,
  messageId: string,
  phone?: string
): Promise<{ status: string; message?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API não configuradas"
      };
    }
    
    console.log(`[Z-API] Excluindo mensagem com ID: ${messageId}`);
    
    // Headers completos para requisição
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para excluir mensagem (conforme documentação Z-API atualizada)
    // O endpoint correto é /message/delete (nova versão da API)
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/message/delete`;
    console.log(`[Z-API] Chamando endpoint: ${endpoint}`);
    
    // Payload conforme documentação atualizada da Z-API
    // https://developer.z-api.io/message/delete-message
    const payload: any = {
      messageId: messageId,
      // Configura para não aparecer para todos (false = remove para todos os participantes)
      onlyForMe: false
    };
    
    // É essencial incluir o número de telefone no payload para identificar corretamente o destinatário
    if (phone) {
      let formattedPhone = phone.replace(/\D/g, '');
      
      // Se o número não tiver o código do país, adiciona o código do Brasil (55)
      if (formattedPhone.length <= 11) {
        formattedPhone = `55${formattedPhone}`;
      }
      
      payload.phone = formattedPhone;
      console.log(`[Z-API] Incluindo número de telefone: ${formattedPhone} (original: ${phone})`);
    } else {
      console.warn(`[Z-API] Aviso: Número de telefone não fornecido para exclusão da mensagem ${messageId}`);
      // Continuamos mesmo sem o telefone, mas é recomendado incluí-lo
    }
    
    console.log(`[Z-API] Enviando payload:`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    console.log(`[Z-API] Resposta da exclusão de mensagem:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme documentação Z-API atualizada
    // A resposta para message/delete é diferente dos outros endpoints e retorna { value: true } se for bem-sucedida
    
    if (response.data && (response.data.value === true || response.status === 200)) {
      console.log(`[Z-API] Mensagem excluída com sucesso`);
      
      return {
        status: "success",
        message: "Mensagem excluída com sucesso"
      };
    } else {
      console.error(`[Z-API] Erro na resposta da exclusão de mensagem:`, response.data);
      
      return {
        status: "error",
        message: "Falha ao excluir mensagem: resposta inválida da Z-API"
      };
    }
  } catch (error) {
    console.error("Erro ao excluir mensagem Z-API:", error);
    
    // Log detalhado para diagnóstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisição"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao excluir mensagem Z-API"
    };
  }
}

export async function sendTestMessageToInbox(channel: Channel): Promise<{ status: string; message?: string }> {
  try {
    // Primeiro verificamos se o canal está conectado
    const connectionStatus = await checkConnectionStatus(channel);
    
    if (connectionStatus.status === "error" || !connectionStatus.connected) {
      return { 
        status: "error", 
        message: "Canal não está conectado. Conecte o WhatsApp antes de testar a caixa de entrada." 
      };
    }
    
    // Em uma implementação real, aqui enviaríamos uma mensagem para um número específico
    // e aguardaríamos o recebimento pelo webhook. Como é um teste, vamos simular.
    
    // Verificar se o webhook está configurado
    const webhookStatus = await checkWebhookStatus(channel);
    
    if (webhookStatus.status === "error" || !webhookStatus.configured) {
      return {
        status: "error",
        message: "Webhook não está configurado. Configure-o antes de testar a caixa de entrada."
      };
    }
    
    return {
      status: "success",
      message: "Teste de mensagem para caixa de entrada realizado com sucesso. Se o webhook estiver configurado corretamente, você receberá as mensagens."
    };
  } catch (error) {
    console.error("Erro ao testar mensagem na caixa de entrada:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao testar mensagem"
    };
  }
}