import axios from 'axios';
import { Channel } from '@shared/schema';

/**
 * Serviﾃｧo de integraﾃｧﾃ｣o com a Z-API (WhatsApp)
 * 
 * Implementa todas as funcionalidades da Z-API para envio e recebimento
 * de mensagens do WhatsApp.
 */

// Configuraﾃｧﾃ｣o global
// Configuraﾃｧﾃｵes da instﾃ｢ncia web (valores das variﾃ｡veis de ambiente ou valores padrﾃ｣o se nﾃ｣o definidos)
const ZAPI_TOKEN = process.env.ZAPI_TOKEN || "A4E42029C248B72DA0842F47";
const ZAPI_INSTANCE_ID = process.env.ZAPI_INSTANCE_ID || "3DF871A7ADFB20FB49998E66062CE0C1";

// Usar CLIENT_TOKEN_ZAPI fornecido pelo usuﾃ｡rio como primeira opﾃｧﾃ｣o, depois cair para os outros
const ZAPI_CLIENT_TOKEN = process.env.CLIENT_TOKEN_ZAPI || 
                          process.env.ZAPI_CLIENT_TOKEN || 
                          "Fa427b12e188a433292a658fe45a07714S";

// Configuraﾃｧﾃｵes alternativas da instﾃ｢ncia mobile para testes
const ZAPI_MOBILE_TOKEN = "8A82365003962876A3574828";
const ZAPI_MOBILE_INSTANCE_ID = "3D0C1D6E493402738F4C266504411D32";

const BASE_URL = 'https://api.z-api.io';

// Z-API Security Token (Token de Seguranﾃｧa da conta, diferente do token da instﾃ｢ncia)
// Este token ﾃｩ usado em todas as instﾃ｢ncias
const ZAPI_SECURITY_TOKEN = "Fa427b12e188a433292a658fe45a07714S";

/**
 * Funﾃｧﾃ｣o auxiliar para formatar botﾃｵes no formato Z-API
 * @param buttons Array de botﾃｵes no formato simples ({ text: string }) ou parcial ({ buttonText: string })
 * @param useActionButtons Flag para usar formato alternativo (nﾃ｣o usado atualmente)
 * @returns Array de botﾃｵes no formato oficial Z-API (com buttonId e buttonText.displayText)
 */
export function formatButtonsForZAPI(buttons: any[], useActionButtons = false) {
  // No formato para send-button-list, os botﾃｵes devem estar no formato:
  // { id: string, text: string }
  // conforme https://developer.z-api.io/message/send-button-list
  
  return buttons.map((button, index) => {
    // Para mensagens com botﾃｵes, o formato deve ser { id: string, text: string }
    return {
      id: button.id || button.buttonId || `btn_${index + 1}`,
      text: button.text || button.buttonText?.displayText || button.buttonText || ""
    };
  });
}

// Log inicial das configuraﾃｧﾃｵes para diagnﾃｳstico
console.log("=================== CONFIGURAﾃﾃグ Z-API ===================");
console.log(`ZAPI_INSTANCE_ID: ${ZAPI_INSTANCE_ID}`);
console.log(`ZAPI_TOKEN: ${ZAPI_TOKEN}`);
console.log(`Client-Token definido: ${ZAPI_CLIENT_TOKEN ? "SIM" : "Nﾃグ"}`);
console.log(`Origem do Client-Token: ${
  process.env.CLIENT_TOKEN_ZAPI ? "CLIENT_TOKEN_ZAPI" : 
  (process.env.ZAPI_CLIENT_TOKEN ? "ZAPI_CLIENT_TOKEN" : "Valor padrﾃ｣o")
}`);
console.log("==========================================================");

// Funﾃｧﾃ｣o de ajuda para garantir que incluﾃｭmos sempre o Client-Token nos headers
function getHeadersWithToken(token: string, clientToken: string = ZAPI_CLIENT_TOKEN) {
  // IMPORTANTE: De acordo com a documentaﾃｧﾃ｣o da Z-API e a coleﾃｧﾃ｣o do Postman,
  // o formato correto do header ﾃｩ 'Client-Token' (com C e T maiﾃｺsculos)
  // https://www.postman.com/docs-z-api/z-api-s-public-workspace/folder/4aisbsg/messages
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    'Client-Token': clientToken,
  };
  
  // Log para diagnﾃｳstico
  console.log(`[Z-API] Headers configurados:`, JSON.stringify(headers));
  
  return headers;
}

/**
 * Testa a conexﾃ｣o com as instﾃ｢ncias Z-API (web e mobile)
 * Esta funﾃｧﾃ｣o ﾃｩ ﾃｺtil para diagnﾃｳstico das credenciais da Z-API
 */
export async function testZapiInstances(): Promise<{
  webInstance: {
    success: boolean;
    message: string;
    data?: any;
  },
  mobileInstance: {
    success: boolean;
    message: string;
    data?: any;
  }
}> {
  const result = {
    webInstance: {
      success: false,
      message: "Nﾃ｣o testado"
    },
    mobileInstance: {
      success: false,
      message: "Nﾃ｣o testado"
    }
  };
  
  // Testar a instﾃ｢ncia web
  try {
    console.log(`Testando instﾃ｢ncia web Z-API (${ZAPI_INSTANCE_ID})...`);
    const webResponse = await axios.get(
      `${BASE_URL}/instances/${ZAPI_INSTANCE_ID}/token/${ZAPI_TOKEN}/status`,
      { headers: getHeadersWithToken(ZAPI_TOKEN) }
    );
    
    result.webInstance = {
      success: true,
      message: "Conexﾃ｣o bem-sucedida",
      data: webResponse.data
    };
  } catch (error) {
    console.error(`Erro ao testar instﾃ｢ncia web Z-API:`, error);
    if (axios.isAxiosError(error)) {
      result.webInstance = {
        success: false,
        message: `Erro ${error.response?.status}: ${error.response?.data?.error || error.message}`,
        data: error.response?.data
      };
    } else {
      result.webInstance = {
        success: false,
        message: error instanceof Error ? error.message : "Erro desconhecido"
      };
    }
  }
  
  // Testar a instﾃ｢ncia mobile
  try {
    console.log(`Testando instﾃ｢ncia mobile Z-API (${ZAPI_MOBILE_INSTANCE_ID})...`);
    const mobileResponse = await axios.get(
      `${BASE_URL}/instances/${ZAPI_MOBILE_INSTANCE_ID}/token/${ZAPI_MOBILE_TOKEN}/status`,
      { headers: getHeadersWithToken(ZAPI_MOBILE_TOKEN) }
    );
    
    result.mobileInstance = {
      success: true,
      message: "Conexﾃ｣o bem-sucedida",
      data: mobileResponse.data
    };
  } catch (error) {
    console.error(`Erro ao testar instﾃ｢ncia mobile Z-API:`, error);
    if (axios.isAxiosError(error)) {
      result.mobileInstance = {
        success: false,
        message: `Erro ${error.response?.status}: ${error.response?.data?.error || error.message}`,
        data: error.response?.data
      };
    } else {
      result.mobileInstance = {
        success: false,
        message: error instanceof Error ? error.message : "Erro desconhecido"
      };
    }
  }
  
  return result;
}

/**
 * Configura o canal Z-API
 * @param channel Canal configurado no sistema
 * @returns Status da configuraﾃｧﾃ｣o com QR Code se necessﾃ｡rio
 */
export async function setupZAPIChannel(channel: Channel): Promise<{ status: string; message?: string; qrCode?: string }> {
  try {
    // Verifica se as credenciais estﾃ｣o disponﾃｭveis
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;

    if (!instanceId || !token) {
      console.log(`[Z-API] Erro: Credenciais nﾃ｣o configuradas para canal ${channel.id}`);
      return {
        status: "error",
        message: "Credenciais da Z-API nﾃ｣o configuradas (instanceId, token)"
      };
    }

    console.log(`[Z-API] Configurando canal ${channel.id} (${channel.name})`);
    console.log(`[Z-API] Instﾃ｢ncia: ${instanceId}`);
    console.log(`[Z-API] Token: ${token.substring(0, 8)}...`);
    console.log(`[Z-API] Client-Token: ${clientToken ? "Configurado" : "Nﾃ｣o configurado"}`);

    // Configurar webhook para recebimento de mensagens (PASSO CRUCIAL)
    console.log(`[Z-API] Iniciando configuraﾃｧﾃ｣o do webhook para canal ${channel.id}...`);
    
    // Determinar a URL base da aplicaﾃｧﾃ｣o para webhooks
    let baseUrl = '';
    if (process.env.APP_URL) {
      baseUrl = process.env.APP_URL;
    } else if (process.env.REPLIT_DOMAINS) {
      baseUrl = `https://${process.env.REPLIT_DOMAINS.split(',')[0]}`;
    } else {
      // URL da Replit atual baseada na ID do projeto
      baseUrl = 'https://0eb8be2b-04a6-47e5-bbf1-dd3bd83018b0-00-2m0jsmtd34bj0.picard.replit.dev';
    }
    
    // URL do webhook especﾃｭfica para este canal
    const webhookUrl = `${baseUrl}/api/webhooks/zapi/${channel.id}`;
    console.log(`[Z-API] URL do webhook a ser configurada: ${webhookUrl}`);
    
    // Chamar a funﾃｧﾃ｣o configureWebhook com todos os eventos necessﾃ｡rios ativados e URL explﾃｭcita
    const webhookResult = await configureWebhook(channel, webhookUrl, {
      receiveAllNotifications: true,
      messageReceived: true,
      messageCreate: true,
      statusChange: true,
      presenceChange: true,
      deviceConnected: true
    });
    
    if (webhookResult.status === "success") {
      console.log(`[Z-API] Webhook configurado com sucesso: ${webhookResult.webhookUrl}`);
      
      // Armazenar a URL do webhook na configuraﾃｧﾃ｣o do canal para referﾃｪncia futura
      try {
        // Importar db para atualizar o canal
        const { db } = await import("../../db");
        const { channels } = await import("../../shared/schema");
        const { eq } = await import("drizzle-orm");
        
        // Atualizar a configuraﾃｧﾃ｣o do canal com informaﾃｧﾃｵes do webhook
        const updatedConfig = {
          ...(channel.config as Record<string, any>),
          webhookUrl: webhookResult.webhookUrl
        };
        
        await db.update(channels)
          .set({ config: updatedConfig })
          .where(eq(channels.id, channel.id));
          
        console.log(`[Z-API] Configuraﾃｧﾃ｣o do canal atualizada com URL do webhook`);
      } catch (dbError) {
        console.error("[Z-API] Erro ao atualizar configuraﾃｧﾃ｣o do canal:", dbError);
        // Continuamos mesmo com erro de atualizaﾃｧﾃ｣o do canal
      }
    } else {
      console.warn(`[Z-API] Alerta: Problema na configuraﾃｧﾃ｣o do webhook: ${webhookResult.message}`);
      // Continuamos o fluxo mesmo com erro no webhook, mas registramos o alerta
    }

    try {
      // Verifica status da conexﾃ｣o
      const statusResponse = await axios.get(
        `${BASE_URL}/instances/${instanceId}/token/${token}/status`,
        {
          headers: getHeadersWithToken(token)
        }
      );

      // Se o status indicar que nﾃ｣o estﾃ｡ conectado, gera QR Code
      if (statusResponse.data && statusResponse.data.connected === false) {
        try {
          // Gera QR Code - modificando para usar endpoint correto e tratar resposta apropriadamente
          // De acordo com a documentaﾃｧﾃ｣o, devemos usar o endpoint qr-code
          const headers: Record<string, string> = {
            ...getHeadersWithToken(token),
            'Accept': 'image/png, application/json',
            'Content-Type': 'application/json'
          };
          
          const qrResponse = await axios.get(
            `${BASE_URL}/instances/${instanceId}/token/${token}/qr-code`,
            {
              headers,
              // Configurar para receber resposta em formato binﾃ｡rio
              responseType: 'arraybuffer',
              // Garantir que nﾃ｣o receberemos HTML (que causaria erro de parsing)
              validateStatus: function (status) {
                return status >= 200 && status < 300; // Aceitar apenas status 2xx
              }
            }
          );

          // Verificar se temos uma resposta de imagem
          if (qrResponse.data) {
            // Converter o buffer recebido para base64
            const qrCodeBase64 = Buffer.from(qrResponse.data).toString('base64');
            
            console.log("QR Code recebido com sucesso e convertido para base64");
            
            return {
              status: "pending",
              message: "Escaneie o QR Code com o WhatsApp para conectar",
              qrCode: qrCodeBase64
            };
          } else {
            console.error("QR Code retornou dados vazios");
            return {
              status: "error",
              message: "Falha ao gerar QR Code para conexﾃ｣o: resposta vazia"
            };
          }
        } catch (error) {
          console.error("Erro ao obter QR Code:", error);
          return {
            status: "error",
            message: `Falha ao gerar QR Code para conexﾃ｣o: ${error instanceof Error ? error.message : "erro desconhecido"}`
          };
        }
      }

      // Webhook jﾃ｡ foi configurado anteriormente no fluxo

      return {
        status: "success",
        message: "Canal Z-API WhatsApp configurado com sucesso"
      };
    } catch (error) {
      console.error("Erro ao configurar Z-API:", error);
      return {
        status: "error",
        message: "Falha ao configurar Z-API"
      };
    }
  } catch (error) {
    console.error("Erro ao configurar canal Z-API:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao configurar Z-API"
    };
  }
}

/**
 * Envia mensagem de texto via Z-API
 * @param channel Canal configurado 
 * @param to Nﾃｺmero de telefone de destino
 * @param content Conteﾃｺdo da mensagem
 * @returns Status do envio com ID da mensagem
 */
export async function sendTextMessage(
  channel: Channel,
  to: string,
  content: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Formataﾃｧﾃ｣o do nﾃｺmero do WhatsApp de acordo com a documentaﾃｧﾃ｣o ATUAL da Z-API
    // Remove todos os caracteres nﾃ｣o numﾃｩricos
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API] Enviando texto para ${formattedPhone} (original: ${to}): "${content}"`);
    console.log(`[Z-API] Usando instﾃ｢ncia: ${instanceId} e token: ${token.slice(0, 5)}...`);
    
    // Headers completos conforme a documentaﾃｧﾃ｣o atualizada
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    console.log(`[Z-API] Headers:`, JSON.stringify(headers));
    
    // Enviar mensagem usando o endpoint correto conforme documentaﾃｧﾃ｣o atual:
    // https://developer.z-api.io/message/send-message-text
    const url = `${BASE_URL}/instances/${instanceId}/token/${token}/send-text`;
    
    console.log(`[Z-API] URL de envio: ${url}`);
    
    // Payload conforme a documentaﾃｧﾃ｣o atual da Z-API
    const payload = {
      phone: formattedPhone,
      message: content,
      isGroup: false // Assumindo que nﾃ｣o ﾃｩ grupo por padrﾃ｣o
    };
    
    console.log(`[Z-API] Payload:`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(url, payload, { headers });
    
    console.log(`[Z-API] Resposta de envio:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme a documentaﾃｧﾃ｣o atualizada
    if (response.data) {
      if (response.data.messageId || response.data.id || response.data.zaapId) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId;
        console.log(`[Z-API] Mensagem enviada com sucesso, ID: ${messageId}`);
        return {
          status: "success",
          messageId: messageId
        };
      } else if (response.data.value === true || response.data.sent === true) {
        // Algumas versﾃｵes da API retornam o campo value/sent como true para indicar sucesso
        console.log(`[Z-API] Mensagem enviada com sucesso, resposta sem ID`);
        
        // Verificar se hﾃ｡ algum outro identificador na resposta
        const alternativeId = response.data.id || response.data.messageId || response.data.messageId || Date.now().toString();
        
        return {
          status: "success",
          messageId: alternativeId
        };
      } else if (typeof response.data === 'string' && response.data.includes('success')) {
        // Algumas versﾃｵes podem retornar apenas uma string de sucesso
        console.log(`[Z-API] Mensagem enviada com sucesso, resposta em formato string`);
        return {
          status: "success",
          messageId: `msg_${Date.now()}`
        };
      }
    }
    
    // Se chegamos atﾃｩ aqui, a resposta nﾃ｣o tem o formato esperado
    console.error(`[Z-API] Resposta de envio em formato inesperado:`, response.data);
    
    // Tentar interpretar mesmo assim para evitar falsos negativos
    if (response.status >= 200 && response.status < 300) {
      console.log(`[Z-API] Considerando mensagem enviada pelo cﾃｳdigo HTTP ${response.status} de sucesso`);
      return {
        status: "success",
        messageId: `unknown_${Date.now()}`,
        message: "Mensagem possivelmente enviada, mas formato de resposta nﾃ｣o reconhecido"
      };
    }
    
    return {
      status: "error",
      message: "Falha ao enviar mensagem via Z-API: Resposta em formato nﾃ｣o reconhecido"
    };
  } catch (error) {
    console.error("Erro ao enviar mensagem Z-API:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      // Se o erro incluir 'Could not find source instance', a instﾃ｢ncia pode estar desconectada
      if (error.response?.data?.error?.includes('find source instance') || 
          error.response?.data?.message?.includes('find source instance')) {
        return {
          status: "error",
          message: "Instﾃ｢ncia Z-API nﾃ｣o encontrada ou desconectada. Verifique a conexﾃ｣o do WhatsApp."
        };
      }
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.response?.data?.message || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar mensagem Z-API"
    };
  }
}

/**
 * Envia mensagem de imagem via Z-API
 * @param channel Canal configurado
 * @param to Nﾃｺmero de telefone de destino
 * @param caption Legenda da imagem
 * @param imageUrl URL da imagem
 * @returns Status do envio com ID da mensagem
 */
export async function sendImageMessage(
  channel: Channel,
  to: string,
  caption: string,
  imageUrl: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Formataﾃｧﾃ｣o correta do nﾃｺmero do WhatsApp de acordo com documentaﾃｧﾃ｣o Z-API
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API] Enviando imagem para ${formattedPhone} (original: ${to})`);
    console.log(`[Z-API] URL da imagem: ${imageUrl}`);
    
    // Headers atualizados conforme documentaﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Enviar imagem usando a estrutura correta do payload conforme documentaﾃｧﾃ｣o oficial
    // https://developer.z-api.io/message/send-message-image
    console.log(`[Z-API DEBUG] Enviando imagem com formato correto...`);
    
    // Verificar se a URL comeﾃｧa com "data:" para identificar Base64
    const isBase64 = imageUrl.startsWith('data:');
    
    // Preparar o payload baseado no tipo de entrada (URL ou Base64)
    const payload: Record<string, any> = {
      phone: formattedPhone,
      caption: caption || ''
    };
    
    // Adicionar campo correto baseado no tipo de entrada
    if (isBase64) {
      console.log(`[Z-API] Enviando imagem como Base64`);
      payload.image = imageUrl; // Base64 com prefixo data:image/png;base64,
    } else {
      console.log(`[Z-API] Enviando imagem como URL`);
      payload.image = imageUrl; // URL direta para imagem
    }
    
    console.log(`[Z-API] Payload (parcial): { phone: "${formattedPhone}", caption: "${caption}", image: "${imageUrl.substring(0, 30)}..." }`);
    
    const response = await axios.post(
      `${BASE_URL}/instances/${instanceId}/token/${token}/send-image`,
      payload,
      { headers }
    );
    
    console.log(`[Z-API DEBUG] Resposta de envio de imagem:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme documentaﾃｧﾃ｣o
    if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
      const messageId = response.data.messageId || response.data.id || response.data.zaapId;
      console.log(`[Z-API] Imagem enviada com sucesso, ID: ${messageId}`);
      return {
        status: "success",
        messageId: messageId
      };
    } else if (response.data && response.data.value) {
      // Algumas versﾃｵes da API retornam o campo value como true para indicar sucesso
      console.log(`[Z-API] Imagem enviada com sucesso, resposta sem ID (usar Z-API mais recente)`);
      return {
        status: "success",
        messageId: "unknown" // Nﾃ｣o temos ID neste caso
      };
    } else {
      console.error(`[Z-API] Resposta de erro ao enviar imagem:`, response.data);
      return {
        status: "error",
        message: "Falha ao enviar imagem via Z-API: Resposta sem ID de mensagem"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar imagem Z-API:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar imagem Z-API"
    };
  }
}

/**
 * Envia mensagem de documento/arquivo via Z-API
 * @param channel Canal configurado
 * @param to Nﾃｺmero de telefone de destino
 * @param caption Legenda do documento
 * @param fileUrl URL do arquivo
 * @param fileName Nome do arquivo
 * @returns Status do envio com ID da mensagem
 */
export async function sendDocumentMessage(
  channel: Channel,
  to: string,
  caption: string,
  fileUrl: string,
  fileName: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Formataﾃｧﾃ｣o correta do nﾃｺmero do WhatsApp de acordo com documentaﾃｧﾃ｣o Z-API
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API] Enviando documento para ${formattedPhone} (original: ${to}): ${fileName}`);
    
    // Headers atualizados conforme documentaﾃｧﾃ｣o 
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    console.log(`[Z-API] Headers para envio de documento:`, JSON.stringify(headers));
    
    // Enviar documento usando o payload correto de acordo com a documentaﾃｧﾃ｣o
    // https://developer.z-api.io/message/send-message-document
    console.log(`[Z-API DEBUG] Enviando documento usando documentaﾃｧﾃ｣o atualizada`);
    
    // Verificar se ﾃｩ base64 ou URL
    const isBase64 = fileUrl.startsWith('data:');
    
    // Montar payload de acordo com o tipo
    const payload: Record<string, any> = {
      phone: formattedPhone,
      fileName: fileName,
      // Remover texto automﾃ｡tico "塘 Documento" da caption
      caption: caption === "塘 Documento" ? "" : (caption || '')
    };
    
    // Adicionar o campo correto de acordo com a documentaﾃｧﾃ｣o atualizada
    if (isBase64) {
      console.log(`[Z-API] Enviando documento como Base64`);
      payload.document = fileUrl;
    } else {
      console.log(`[Z-API] Enviando documento como URL`);
      payload.document = fileUrl;
    }
    
    // Extrair a extensﾃ｣o do arquivo
    const fileExtension = fileName.split('.').pop()?.toLowerCase() || '';
    if (!fileExtension) {
      console.warn(`[Z-API] AVISO: Nﾃ｣o foi possﾃｭvel extrair a extensﾃ｣o do arquivo "${fileName}". Usando "txt" como padrﾃ｣o.`);
    }
    
    // Incluir a extensﾃ｣o no endpoint conforme documentaﾃｧﾃ｣o
    const extension = fileExtension || 'txt';
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-document/${extension}`;
    
    console.log(`[Z-API] Enviando para endpoint com extensﾃ｣o: ${endpoint}`);
    
    const response = await axios.post(
      endpoint,
      payload,
      { headers }
    );
    
    console.log(`[Z-API] Resposta de envio de documento:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme documentaﾃｧﾃ｣o
    if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
      const messageId = response.data.messageId || response.data.id || response.data.zaapId;
      console.log(`[Z-API] Documento enviado com sucesso, ID: ${messageId}`);
      return {
        status: "success",
        messageId: messageId
      };
    } else if (response.data && response.data.value) {
      // Algumas versﾃｵes da API retornam o campo value como true para indicar sucesso
      console.log(`[Z-API] Documento enviado com sucesso, resposta sem ID (usar Z-API mais recente)`);
      return {
        status: "success",
        messageId: "unknown" // Nﾃ｣o temos ID neste caso
      };
    } else {
      console.error(`[Z-API] Resposta de erro ao enviar documento:`, response.data);
      return {
        status: "error",
        message: "Falha ao enviar documento via Z-API: Resposta sem ID de mensagem"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar documento Z-API:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar documento Z-API"
    };
  }
}

/**
 * Envia mensagem de vﾃｭdeo via Z-API
 * @param channel Canal configurado
 * @param to Nﾃｺmero de telefone de destino
 * @param videoUrl URL do vﾃｭdeo a ser enviado
 * @param caption Legenda opcional para o vﾃｭdeo
 * @returns Status do envio com ID da mensagem
 */
export async function sendVideoMessage(
  channel: Channel,
  to: string,
  videoUrl: string,
  caption?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Formataﾃｧﾃ｣o do nﾃｺmero do WhatsApp conforme documentaﾃｧﾃ｣o
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API DEBUG] Enviando vﾃｭdeo para ${formattedPhone} (original: ${to}): "${videoUrl}"`);
    console.log(`[Z-API DEBUG] Caption: "${caption || 'sem legenda'}"`);
    console.log(`[Z-API DEBUG] Token: "${token.substring(0, 4)}...${token.substring(token.length - 4)}"`);
    console.log(`[Z-API DEBUG] InstanceID: "${instanceId}"`);
    
    // Headers completos para requisiﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de vﾃｭdeo
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-video`;
    console.log(`[Z-API DEBUG] Chamando endpoint: ${endpoint}`);
    
    // Faremos mﾃｺltiplas tentativas com diferentes formatos aceitos pela API
    let lastError: any = null;
    
    // Verificar se ﾃｩ base64 ou URL
    const isBase64 = videoUrl.startsWith('data:');
    
    // Tentativa 1: Usando o campo correto conforme a documentaﾃｧﾃ｣o mais recente
    try {
      console.log(`[Z-API DEBUG] Tentativa 1: Usando campo 'video' ${isBase64 ? '(Base64)' : '(URL)'}`);
      const response = await axios.post(
        endpoint,
        {
          phone: formattedPhone,
          video: videoUrl,
          caption: caption === "汐 Vﾃｭdeo" ? "" : (caption || '')
        },
        { headers }
      );
      
      console.log(`[Z-API DEBUG] Resposta 1:`, JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId || response.data.value === true)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId || "unknown";
        return {
          status: "success",
          messageId
        };
      }
    } catch (err: any) {
      console.error("[Z-API DEBUG] Erro na tentativa 1:", err.message);
      lastError = err;
    }
    
    // Tentativa 2: Usando linkVideo (documentaﾃｧﾃ｣o anterior)
    try {
      console.log("[Z-API DEBUG] Tentativa 2: Usando campo 'linkVideo'");
      const response = await axios.post(
        endpoint,
        {
          phone: formattedPhone,
          linkVideo: videoUrl,
          caption: caption === "汐 Vﾃｭdeo" ? "" : (caption || '')
        },
        { headers }
      );
      
      console.log(`[Z-API DEBUG] Resposta 2:`, JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId || response.data.value === true)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId || "unknown";
        return {
          status: "success",
          messageId
        };
      }
    } catch (err: any) {
      console.error("[Z-API DEBUG] Erro na tentativa 2:", err.message);
      lastError = err;
    }
    
    // Tentativa 3: Usando o endpoint genﾃｩrico send-media
    try {
      console.log("[Z-API DEBUG] Tentativa 3: Usando endpoint 'send-media'");
      const mediaEndpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-media`;
      
      const response = await axios.post(
        mediaEndpoint,
        {
          phone: formattedPhone,
          url: videoUrl,
          type: 'video',
          caption: caption === "汐 Vﾃｭdeo" ? "" : (caption || '')
        },
        { headers }
      );
      
      console.log(`[Z-API DEBUG] Resposta 3:`, JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId || response.data.value === true)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId || "unknown";
        return {
          status: "success",
          messageId
        };
      }
    } catch (err: any) {
      console.error("[Z-API DEBUG] Erro na tentativa 3:", err.message);
      lastError = err;
    }
    
    // Se chegamos aqui, todas as tentativas falharam
    console.error("[Z-API DEBUG] Todas as tentativas de envio de vﾃｭdeo falharam");
    
    if (lastError && axios.isAxiosError(lastError)) {
      return {
        status: "error",
        message: `Erro Z-API: ${lastError.response?.status || ''} - ${lastError.response?.data?.error || lastError.message}`
      };
    }
    
    return {
      status: "error",
      message: "Falha ao enviar vﾃｭdeo apﾃｳs mﾃｺltiplas tentativas"
    };
  } catch (error: any) {
    console.error("[Z-API DEBUG] Erro geral:", error.message);
    return {
      status: "error",
      message: `Erro ao enviar vﾃｭdeo: ${error.message}`
    };
  }
}

/**
 * Envia mensagem de ﾃ｡udio via Z-API
 * @param channel Canal configurado
 * @param to Nﾃｺmero de telefone de destino
 * @param audioUrl URL do arquivo de ﾃ｡udio
 * @returns Status do envio com ID da mensagem
 */
export async function sendAudioMessage(
  channel: Channel,
  to: string,
  audioUrl: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    // Log detalhado para diagnﾃｳstico
    console.log("[Z-API] Iniciando envio de ﾃ｡udio");
    console.log(`[Z-API] URL de ﾃ｡udio: ${audioUrl}`);
    
    // Verificar se o ﾃ｡udio ﾃｩ MP3 (compatﾃｭvel com WhatsApp)
    const isMP3 = audioUrl.toLowerCase().includes('.mp3');
    if (!isMP3) {
      console.log(`[Z-API] ALERTA: URL de ﾃ｡udio nﾃ｣o parece ser MP3: ${audioUrl}`);
      console.log(`[Z-API] O WhatsApp pode ter problemas reproduzindo ﾃ｡udios que nﾃ｣o estejam em formato MP3`);
    }
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Formataﾃｧﾃ｣o correta do nﾃｺmero do WhatsApp de acordo com documentaﾃｧﾃ｣o Z-API
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    // Verificar se o nﾃｺmero ﾃｩ um grupo
    const isGroup = to.includes('-group') || to.includes('@g.us');
    
    // Se for um grupo, precisamos usar o ID do grupo sem formataﾃｧﾃ｣o
    if (isGroup) {
      formattedPhone = to;
      console.log(`[Z-API] Detectado grupo: ${formattedPhone}`);
    } else {
      console.log(`[Z-API] Enviando ﾃ｡udio para contato: ${formattedPhone} (original: ${to})`);
    }
    
    // Headers completos para requisiﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de ﾃ｡udio
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-audio`;
    
    // Estratﾃｩgia: Tente vﾃ｡rios formatos de payload, comeﾃｧando pelo mais recente documentado
    // Cada versﾃ｣o da Z-API pode ter pequenas diferenﾃｧas
    
    // Tentativa 1: Formato padrﾃ｣o documentado
    try {
      console.log("[Z-API] Tentativa 1: Usando formato oficial da documentaﾃｧﾃ｣o");
      
      // Verificar se ﾃｩ base64 ou URL
      const isBase64Audio = audioUrl.startsWith('data:');
      
      // Payload conforme documentaﾃｧﾃ｣o mais recente
      const payload = {
        phone: formattedPhone,
        audio: audioUrl,     // URL do ﾃ｡udio ou Base64
        viewOnce: false,     // Nﾃ｣o ﾃｩ mensagem de visualizaﾃｧﾃ｣o ﾃｺnica
        waveform: true       // Mostrar ondas sonoras (efeito visual)
      };
      
      console.log(`[Z-API] Enviando ﾃ｡udio como ${isBase64Audio ? 'Base64' : 'URL'}`)
      
      console.log("[Z-API] Enviando payload 1:", JSON.stringify(payload, null, 2));
      
      const response = await axios.post(endpoint, payload, { headers });
      
      console.log("[Z-API] Resposta 1:", JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId;
        console.log(`[Z-API] ﾃ「dio enviado com sucesso! ID: ${messageId}`);
        return {
          status: "success",
          messageId
        };
      } else if (response.data && response.data.value === true) {
        // Algumas versﾃｵes da API retornam apenas {value: true} para indicar sucesso
        console.log(`[Z-API] ﾃ「dio enviado com sucesso! (sem ID retornado)`);
        return {
          status: "success",
          messageId: "unknown"
        };
      }
    } catch (err) {
      console.error("[Z-API] Erro na tentativa 1:", err instanceof Error ? err.message : String(err));
      if (axios.isAxiosError(err) && err.response) {
        console.error(`[Z-API] Status: ${err.response.status}, Dados:`, err.response.data);
      }
    }
    
    // Tentativa 2: Formato alternativo (algumas versﾃｵes anteriores da Z-API)
    try {
      console.log("[Z-API] Tentativa 2: Usando formato alternativo");
      
      // Payload alternativo (algumas implementaﾃｧﾃｵes anteriores)
      const payload = {
        phone: formattedPhone,
        url: audioUrl,       // Algumas versﾃｵes usam 'url' em vez de 'audio'
        options: {
          viewOnce: false,
          waveform: true
        }
      };
      
      console.log("[Z-API] Enviando payload 2:", JSON.stringify(payload, null, 2));
      
      const response = await axios.post(endpoint, payload, { headers });
      
      console.log("[Z-API] Resposta 2:", JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId;
        console.log(`[Z-API] ﾃ「dio enviado com sucesso (formato alternativo)! ID: ${messageId}`);
        return {
          status: "success",
          messageId
        };
      } else if (response.data && response.data.value === true) {
        console.log(`[Z-API] ﾃ「dio enviado com sucesso (formato alternativo, sem ID)!`);
        return {
          status: "success",
          messageId: "unknown"
        };
      }
    } catch (err) {
      console.error("[Z-API] Erro na tentativa 2:", err instanceof Error ? err.message : String(err));
      if (axios.isAxiosError(err) && err.response) {
        console.error(`[Z-API] Status: ${err.response.status}, Dados:`, err.response.data);
      }
    }
    
    // Tentativa 3: Usando endpoint genﾃｩrico de mﾃｭdia (ﾃｺltima tentativa)
    try {
      console.log("[Z-API] Tentativa 3: Usando endpoint genﾃｩrico de mﾃｭdia");
      
      const mediaEndpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-media`;
      
      const payload = {
        phone: formattedPhone,
        url: audioUrl,
        type: 'audio',       // Especificar que ﾃｩ ﾃ｡udio
        caption: ''          // Sem legenda
      };
      
      console.log("[Z-API] Enviando payload 3:", JSON.stringify(payload, null, 2));
      
      const response = await axios.post(mediaEndpoint, payload, { headers });
      
      console.log("[Z-API] Resposta 3:", JSON.stringify(response.data, null, 2));
      
      if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
        const messageId = response.data.messageId || response.data.id || response.data.zaapId;
        console.log(`[Z-API] ﾃ「dio enviado com sucesso (endpoint genﾃｩrico)! ID: ${messageId}`);
        return {
          status: "success",
          messageId
        };
      } else if (response.data && response.data.value === true) {
        console.log(`[Z-API] ﾃ「dio enviado com sucesso (endpoint genﾃｩrico, sem ID)!`);
        return {
          status: "success",
          messageId: "unknown"
        };
      }
    } catch (err) {
      console.error("[Z-API] Erro na tentativa 3:", err instanceof Error ? err.message : String(err));
      if (axios.isAxiosError(err) && err.response) {
        console.error(`[Z-API] Status: ${err.response.status}, Dados:`, err.response.data);
      }
    }
    
    // Se chegamos aqui, todas as tentativas falharam
    console.error("[Z-API] Todas as tentativas de envio de ﾃ｡udio falharam");
    return {
      status: "error",
      message: "Falha no envio de ﾃ｡udio: O servidor Z-API nﾃ｣o aceitou nenhum dos formatos de envio"
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Erro desconhecido";
    console.error(`[Z-API] Erro geral no envio de ﾃ｡udio: ${errorMessage}`);
    return {
      status: "error",
      message: `Erro ao enviar ﾃ｡udio: ${errorMessage}`
    };
  }
}

/**
 * Sincroniza contatos do WhatsApp via Z-API
 * @param channel Canal configurado
 * @returns Lista de contatos sincronizados
 */
export async function syncContacts(channel: Channel): Promise<{ status: string; message?: string; contacts?: any[] }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Obter contatos
    const response = await axios.get(
      `${BASE_URL}/instances/${instanceId}/token/${token}/contacts`,
      {
        headers: getHeadersWithToken(token)
      }
    );
    
    if (response.data && Array.isArray(response.data.contacts)) {
      return {
        status: "success",
        contacts: response.data.contacts
      };
    } else {
      return {
        status: "error",
        message: "Falha ao sincronizar contatos"
      };
    }
  } catch (error) {
    console.error("Erro ao sincronizar contatos Z-API:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao sincronizar contatos"
    };
  }
}

/**
 * Verifica o status da conexﾃ｣o com o WhatsApp
 * @param channel Canal configurado
 * @returns Status da conexﾃ｣o
 */
export async function checkConnectionStatus(channel: Channel): Promise<{ status: string; message?: string; connected?: boolean }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    console.log(`[Z-API] Verificando status da conexﾃ｣o: ${instanceId}`);
    
    // Headers atualizados conforme documentaﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    console.log(`[Z-API] Headers para verificaﾃｧﾃ｣o de status:`, JSON.stringify(headers));
    
    // Verificar status
    const response = await axios.get(
      `${BASE_URL}/instances/${instanceId}/token/${token}/status`,
      { 
        headers,
        // Configurar para validar apenas respostas de sucesso
        validateStatus: function (status) {
          return status >= 200 && status < 300; // Aceitar apenas status 2xx
        },
        // Timeout para evitar esperas muito longas
        timeout: 10000
      }
    );
    
    if (response.data) {
      console.log(`[Z-API] Resposta de status:`, JSON.stringify(response.data));
      
      // Verificar se estﾃ｡ conectado - na Z-API, um smartphone conectado ﾃｩ o que indica
      // que o WhatsApp estﾃ｡ realmente conectado, nﾃ｣o apenas a instﾃ｢ncia
      const isConnected = response.data.connected === true && 
                          response.data.smartphoneConnected === true;
      
      return {
        status: isConnected ? "connected" : "disconnected",
        connected: isConnected,
        message: isConnected ? "WhatsApp conectado" : "WhatsApp desconectado"
      };
    } else {
      return {
        status: "error",
        message: "Nﾃ｣o foi possﾃｭvel verificar o status da conexﾃ｣o"
      };
    }
  } catch (error) {
    console.error("[Z-API] Erro ao verificar status:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao verificar status"
    };
  }
}

/**
 * Obtﾃｩm o QR Code para conexﾃ｣o de um canal Z-API com o WhatsApp
 * @param channel Canal Z-API configurado
 * @returns Objeto com status e QR Code em base64 (se disponﾃｭvel)
 */
export async function getQRCodeForChannel(channel: Channel): Promise<{ status: string; message?: string; qrCode?: string }> {
  try {
    console.log("================= OBTENDO QR CODE PARA CANAL =================");
    console.log(`Canal ID: ${channel.id}`);
    console.log(`Canal Nome: ${channel.name}`);
    console.log(`Canal Tipo: ${channel.type}`);

    // Usar valores globais conhecidos que funcionam
    const instanceId = ZAPI_INSTANCE_ID;
    const token = ZAPI_TOKEN;
    const clientToken = ZAPI_CLIENT_TOKEN;
    
    // Log dos valores utilizados para diagnﾃｳstico
    console.log("Credenciais Z-API usadas:");
    console.log(`Instance ID: ${instanceId}`);
    console.log(`Token: ${token}`);
    console.log(`Client-Token: ${clientToken.substring(0, 5)}...${clientToken.substring(clientToken.length - 5)}`);
    
    if (!instanceId || !token || !clientToken) {
      console.error("Credenciais Z-API nﾃ｣o configuradas completamente");
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas completamente"
      };
    }
    
    // Estrutura do header exatamente como esperado pela Z-API (com C e T maiﾃｺsculos em Client-Token)
    const headers = {
      'Content-Type': 'application/json',
      'Accept': 'image/png,application/json',
      'Client-Token': clientToken
    };
    
    console.log(`Headers a serem utilizados:`, JSON.stringify(headers));
    console.log(`URL a ser chamada: ${BASE_URL}/instances/${instanceId}/token/${token}/qr-code`);
    
    try {
      console.log("Solicitando QR code diretamente...");
      
      const qrResponse = await axios.get(
        `${BASE_URL}/instances/${instanceId}/token/${token}/qr-code`,
        { 
          headers,
          responseType: 'arraybuffer',
          // Configurar para validar apenas respostas de sucesso
          validateStatus: function (status) {
            return status >= 200 && status < 300; // Aceitar apenas status 2xx
          },
          // Timeout para evitar esperas muito longas
          timeout: 10000 
        }
      );
      
      console.log("Resposta da API /qr-code recebida com status:", qrResponse.status);
      
      // Se temos dados na resposta
      if (qrResponse.data && qrResponse.data.length > 0) {
        console.log(`Recebido buffer de tamanho: ${qrResponse.data.length} bytes`);
        
        try {
          // A Z-API estﾃ｡ retornando um objeto JSON em vez de uma imagem direta
          // Primeiro, vamos converter para texto e verificar a estrutura
          const responseText = Buffer.from(qrResponse.data).toString('utf-8');
          console.log("Primeiros 100 caracteres da resposta:", responseText.substring(0, 100) + "...");
          
          // Tentar converter para JSON
          let qrObject;
          try {
            qrObject = JSON.parse(responseText);
            console.log("Formato da resposta JSON:", Object.keys(qrObject).join(", "));
          } catch (jsonError) {
            console.log("Resposta nﾃ｣o ﾃｩ um JSON vﾃ｡lido, tratando como imagem direta");
            // Se nﾃ｣o for JSON, vamos criar a string base64 direto da imagem
            const qrCodeBase64Direct = `data:image/png;base64,${Buffer.from(qrResponse.data).toString('base64')}`;
            
            return {
              status: "waiting_scan",
              message: "Escaneie o QR Code com o WhatsApp para conectar",
              qrCode: qrCodeBase64Direct
            };
          }
          
          // Se o objeto possui a propriedade 'connected': true, entﾃ｣o jﾃ｡ estﾃ｡ conectado
          if (qrObject && qrObject.connected === true) {
            console.log("Instﾃ｢ncia jﾃ｡ estﾃ｡ conectada ao WhatsApp");
            return {
              status: "connected",
              message: "O WhatsApp jﾃ｡ estﾃ｡ conectado a esta instﾃ｢ncia"
            };
          }
          
          // Se temos um objeto JSON com a propriedade 'value', ﾃｩ o caso que estamos encontrando
          if (qrObject && qrObject.value) {
            console.log("QR Code retornado como JSON com propriedade 'value'");
            console.log("Valor recebido para QR code:", qrObject.value);
            
            // Retornar o valor diretamente em vez de uma URL, jﾃ｡ que o handler vai processar
            return {
              status: "waiting_scan",
              message: "Escaneie o QR Code com o WhatsApp para conectar",
              qrCode: qrObject.value
            };
          } else {
            console.log("QR Code em formato nﾃ｣o reconhecido:", Object.keys(qrObject).join(", "));
            // Fallback para a abordagem anterior
            const qrCodeBase64Fallback = `data:image/png;base64,${Buffer.from(qrResponse.data).toString('base64')}`;
            
            return {
              status: "waiting_scan",
              message: "Escaneie o QR Code com o WhatsApp para conectar",
              qrCode: qrCodeBase64Fallback
            };
          }
        } catch (error) {
          console.error("Erro no processamento do QR code:", error);
          // Fallback para o mﾃｩtodo original em caso de erro no processamento
          const qrCodeBase64Fallback = `data:image/png;base64,${Buffer.from(qrResponse.data).toString('base64')}`;
          
          return {
            status: "waiting_scan", 
            message: "Escaneie o QR Code com o WhatsApp para conectar (processamento alternativo)",
            qrCode: qrCodeBase64Fallback
          };
        }
      } 
      
      // Retornar erro se nﾃ｣o conseguiu obter o QR code
      console.error("QR Code retornou dados vazios");
      return {
        status: "error",
        message: "Falha ao gerar QR Code para conexﾃ｣o: resposta vazia"
      };
      
    } catch (qrError) {
      console.error("Erro ao solicitar QR Code:", qrError);
      
      // Log detalhado do erro para diagnﾃｳstico
      if (axios.isAxiosError(qrError)) {
        const status = qrError.response?.status;
        const headers = qrError.response?.headers;
        const data = qrError.response?.data;
        
        console.error(`Status da resposta: ${status}`);
        
        if (data) {
          try {
            // Tentar extrair informaﾃｧﾃｵes do erro
            const dataStr = Buffer.isBuffer(data) 
              ? Buffer.from(data).toString() 
              : typeof data === 'object'
                ? JSON.stringify(data)
                : String(data);
            
            console.error(`Dados da resposta: ${dataStr.substring(0, 300)}...`);
          } catch (convErr) {
            console.error("Nﾃ｣o foi possﾃｭvel converter os dados da resposta");
          }
        }
      }
      
      return {
        status: "error",
        message: qrError instanceof Error 
          ? `Falha ao solicitar QR Code: ${qrError.message}` 
          : "Erro desconhecido ao solicitar QR Code"
      };
    }
  } catch (error) {
    console.error("Erro geral na obtenﾃｧﾃ｣o do QR Code:", error);
    return {
      status: "error",
      message: error instanceof Error 
        ? `Erro geral na obtenﾃｧﾃ｣o do QR Code: ${error.message}` 
        : "Erro desconhecido na obtenﾃｧﾃ｣o do QR Code"
    };
  }
}

/**
 * Desconecta a sessﾃ｣o do WhatsApp
 * @param channel Canal configurado
 * @returns Status da operaﾃｧﾃ｣o
 */
export async function disconnectSession(channel: Channel): Promise<{ status: string; message?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Headers atualizados conforme documentaﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    console.log(`[Z-API] Desconectando sessﾃ｣o para instﾃ｢ncia ${instanceId}`);
    console.log(`[Z-API] Headers para desconexﾃ｣o:`, JSON.stringify(headers));
    
    // Desconectar sessﾃ｣o
    const response = await axios.get(
      `${BASE_URL}/instances/${instanceId}/token/${token}/disconnect`,
      { headers }
    );
    
    console.log(`[Z-API] Resposta da desconexﾃ｣o:`, JSON.stringify(response.data, null, 2));
    
    return {
      status: "success",
      message: "Sessﾃ｣o desconectada com sucesso"
    };
  } catch (error) {
    console.error("[Z-API] Erro ao desconectar sessﾃ｣o:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao desconectar sessﾃ｣o"
    };
  }
}

/**
 * Reinicia a sessﾃ｣o do WhatsApp
 * @param channel Canal configurado
 * @returns Status da operaﾃｧﾃ｣o
 */
export async function restartSession(channel: Channel): Promise<{ status: string; message?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Headers atualizados conforme documentaﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    console.log(`[Z-API] Reiniciando sessﾃ｣o para instﾃ｢ncia ${instanceId}`);
    console.log(`[Z-API] Headers para reinicializaﾃｧﾃ｣o:`, JSON.stringify(headers));
    
    // Reiniciar sessﾃ｣o
    const response = await axios.get(
      `${BASE_URL}/instances/${instanceId}/token/${token}/restart`,
      { headers }
    );
    
    console.log(`[Z-API] Resposta da reinicializaﾃｧﾃ｣o:`, JSON.stringify(response.data, null, 2));
    
    return {
      status: "success",
      message: "Sessﾃ｣o reiniciada com sucesso. Aguarde alguns segundos e reconecte com QR Code."
    };
  } catch (error) {
    console.error("[Z-API] Erro ao reiniciar sessﾃ｣o:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao reiniciar sessﾃ｣o"
    };
  }
}

/**
 * Verifica o status do webhook configurado para um canal
 * @param channel Canal a ser verificado
 * @returns Objeto com status da verificaﾃｧﾃ｣o
 */
export async function checkWebhookStatus(channel: Channel): Promise<{ 
  status: string; 
  message?: string; 
  configured?: boolean;
  webhookUrl?: string;
  webhookFeatures?: {
    receiveAllNotifications?: boolean;
    messageReceived?: boolean;
    messageCreate?: boolean;
    statusChange?: boolean;
    presenceChange?: boolean;
    deviceConnected?: boolean;
    receiveByEmail?: boolean;
  };
}> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    console.log(`[Z-API] Verificando status do webhook para canal ${channel.id} (instﾃ｢ncia ${instanceId})...`);
    
    // Determinar a URL correta do webhook com base nas informaﾃｧﾃｵes do canal
    let baseUrl = '';
    if (process.env.APP_URL) {
      baseUrl = process.env.APP_URL;
    } else if (process.env.REPLIT_DOMAINS) {
      baseUrl = `https://${process.env.REPLIT_DOMAINS.split(',')[0]}`;
    } else {
      baseUrl = 'https://0eb8be2b-04a6-47e5-bbf1-dd3bd83018b0-00-2m0jsmtd34bj0.picard.replit.dev';
    }
    
    // URL esperada do webhook (deve corresponder ﾃ URL configurada)
    const expectedWebhookUrl = `${baseUrl}/api/webhooks/zapi/${channel.id}`;
    
    try {
      // CORREﾃﾃグ IMPORTANTE: Se o webhook estiver configurado nos metadados do canal,
      // vamos considerar que estﾃ｡ configurado sem precisar verificar na API.
      // Isso evita problemas com verificaﾃｧﾃｵes que falham na API mas o webhook estﾃ｡ funcionando
      if (channel.metadata && 
          channel.metadata.webhookConfigured === true && 
          channel.metadata.webhookUrl) {
        
        console.log(`[Z-API] Usando dados armazenados para canal ${channel.id}: webhook configurado para ${channel.metadata.webhookUrl}`);
        
        // Usar os dados que temos armazenados para retorno
        return {
          status: "success",
          configured: true,
          webhookUrl: channel.metadata.webhookUrl,
          webhookFeatures: channel.metadata.webhookFeatures || {
            receiveAllNotifications: true,
            messageReceived: true,
            messageCreate: true,
            statusChange: true,
            presenceChange: true, 
            deviceConnected: true,
            receiveByEmail: false
          },
          message: `Webhook configurado para: ${channel.metadata.webhookUrl} (dados armazenados)`
        };
      }
      
      // Se nﾃ｣o temos metadados ou precisamos atualizar, tentamos verificar na API
      const headers = getHeadersWithToken(token, ZAPI_CLIENT_TOKEN);
      
      console.log(`[Z-API] Headers configurados: ${JSON.stringify(headers, null, 2)}`);
      console.log(`[Z-API] Fazendo requisiﾃｧﾃ｣o GET para ${BASE_URL}/instances/${instanceId}/token/${token}/webhook`);
      
      try {
        const response = await axios.get(
          `${BASE_URL}/instances/${instanceId}/token/${token}/webhook`,
          { headers }
        );
        
        console.log(`[Z-API] Resposta da verificaﾃｧﾃ｣o de webhook:`, JSON.stringify(response.data, null, 2));
        
        // Compatibilidade com todas as versﾃｵes da API Z-API (nova e antiga)
        // A API mais recente retorna objeto com 'url', a antiga retorna objeto com 'value'
        // Algumas versﾃｵes podem retornar diretamente a string da URL
        let webhookUrl = null;
        if (typeof response.data === 'string' && response.data.startsWith('http')) {
          // Caso 1: Resposta ﾃｩ diretamente a URL como string
          webhookUrl = response.data;
        } else if (response.data?.url) {
          // Caso 2: Resposta tem formato { url: "https://..." }
          webhookUrl = response.data.url;
        } else if (response.data?.value && typeof response.data.value === 'string') {
          // Caso 3: Resposta tem formato { value: "https://..." }
          webhookUrl = response.data.value;
        }
        
        const isConfigured = !!webhookUrl && webhookUrl.length > 0;
        
        // Extrair features do webhook se existirem
        // API nova: webhookFeatures ﾃｩ um objeto com propriedades booleanas
        // API antiga: pode nﾃ｣o ter essas propriedades
        const webhookFeatures = response.data?.webhookFeatures || {};
        
        return {
          status: "success",
          configured: isConfigured,
          webhookUrl: webhookUrl,
          webhookFeatures: {
            receiveAllNotifications: webhookFeatures.receiveAllNotifications || false,
            messageReceived: webhookFeatures.messageReceived || false,
            messageCreate: webhookFeatures.messageCreate || false,
            statusChange: webhookFeatures.statusChange || false,
            presenceChange: webhookFeatures.presenceChange || false,
            deviceConnected: webhookFeatures.deviceConnected || false,
            receiveByEmail: webhookFeatures.receiveByEmail || false
          },
          message: isConfigured 
            ? `Webhook configurado para: ${webhookUrl}` 
            : 'Webhook nﾃ｣o configurado'
        };
      } catch (error) {
        console.log(`[Z-API] Erro esperado ao verificar webhook (mﾃｩtodo GET):`, error.message);
        
        // Verificar se o webhook foi configurado nos metadados do canal
        if (channel.metadata && channel.metadata.webhookConfigured === true) {
          console.log(`[Z-API] Webhook estﾃ｡ configurado de acordo com os metadados do canal`);
          
          // Retornar as informaﾃｧﾃｵes salvas nos metadados
          return {
            status: "success",
            configured: true,
            webhookUrl: expectedWebhookUrl,
            webhookFeatures: {
              receiveAllNotifications: true,
              messageReceived: true,
              messageCreate: true,
              statusChange: true,
              presenceChange: true,
              deviceConnected: true,
              receiveByEmail: false
            },
            message: `Webhook configurado para: ${expectedWebhookUrl}`
          };
        }
        
        // Vamos verificar o status da instﾃ｢ncia como alternativa
        console.log(`[Z-API] Mﾃｩtodo alternativo: verificar status da instﾃ｢ncia...`);
        
        try {
          const connectionStatus = await checkConnectionStatus(channel);
          
          if (connectionStatus.status === "success" && connectionStatus.connected) {
            // Se a instﾃ｢ncia estﾃ｡ conectada, provavelmente o webhook funciona tambﾃｩm
            // mas a API nﾃ｣o estﾃ｡ retornando o status corretamente
            console.log(`[Z-API] Instﾃ｢ncia estﾃ｡ conectada, assumindo que o webhook estﾃ｡ configurado`);
            
            return {
              status: "success",
              configured: true,
              webhookUrl: expectedWebhookUrl,
              webhookFeatures: {
                receiveAllNotifications: true,
                messageReceived: true,
                messageCreate: true,
                statusChange: true,
                presenceChange: true,
                deviceConnected: true,
                receiveByEmail: false
              },
              message: `Webhook assumido como configurado (instﾃ｢ncia conectada)`
            };
          }
        } catch (statusError) {
          console.error("[Z-API] Erro ao verificar status alternativo:", statusError);
        }
        
        // Se chegamos aqui, realmente o webhook nﾃ｣o estﾃ｡ configurado
        return {
          status: "success",
          configured: false,
          webhookUrl: null,
          webhookFeatures: {
            receiveAllNotifications: false,
            messageReceived: false,
            messageCreate: false,
            statusChange: false,
            presenceChange: false,
            deviceConnected: false,
            receiveByEmail: false
          },
          message: "Webhook nﾃ｣o configurado"
        };
      }
    } catch (error) {
      console.error("[Z-API] Erro ao verificar webhook:", error);
      
      let errorMessage = "Erro desconhecido ao verificar webhook";
      if (axios.isAxiosError(error)) {
        const responseData = error.response?.data;
        errorMessage = responseData?.error || responseData?.message || error.message;
        console.error("[Z-API] Detalhes da resposta:", JSON.stringify(error.response?.data, null, 2));
      } else if (error instanceof Error) {
        errorMessage = error.message;
      }
      
      return {
        status: "error",
        configured: false,
        message: errorMessage
      };
    }
  } catch (error) {
    console.error("[Z-API] Erro ao verificar webhook:", error);
    
    let errorMessage = "Erro desconhecido ao verificar webhook";
    if (axios.isAxiosError(error)) {
      const responseData = error.response?.data;
      errorMessage = responseData?.error || responseData?.message || error.message;
      console.error("[Z-API] Detalhes da resposta:", JSON.stringify(error.response?.data, null, 2));
    } else if (error instanceof Error) {
      errorMessage = error.message;
    }
    
    return {
      status: "error",
      configured: false,
      message: errorMessage
    };
  }
}

/**
 * Configura o webhook para recebimento de mensagens em um canal
 * @param channel Canal a ser configurado
 * @param webhookUrl URL opcional do webhook (senﾃ｣o, serﾃ｡ usada a URL padrﾃ｣o do sistema)
 * @param webhookFeatures Configuraﾃｧﾃｵes especﾃｭficas de recursos do webhook
 * @returns Objeto com status da configuraﾃｧﾃ｣o
 */
/**
 * Marca uma mensagem como lida no WhatsApp
 * @param channel Canal configurado
 * @param messageId ID da mensagem a ser marcada como lida
 * @returns Status da operaﾃｧﾃ｣o
 */
export async function markMessageAsRead(
  channel: Channel,
  messageId: string
): Promise<{ status: string; message?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Marcando mensagem como lida na Z-API
    console.log(`[Z-API] Marcando mensagem ${messageId} como lida`);
    
    // Endpoint da API Z-API para marcar como lida
    const response = await axios.post(
      `${BASE_URL}/instances/${instanceId}/token/${token}/read-message`,
      {
        messageId
      },
      {
        headers: getHeadersWithToken(token)
      }
    );
    
    // Verificar resposta
    if (response.data && response.data.success) {
      return {
        status: "success",
        message: "Mensagem marcada como lida com sucesso"
      };
    } else {
      return {
        status: "error",
        message: "Falha ao marcar mensagem como lida"
      };
    }
  } catch (error) {
    console.error("Erro ao marcar mensagem como lida na Z-API:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao marcar mensagem como lida"
    };
  }
}

export async function configureWebhook(
  channel: Channel, 
  webhookUrl?: string,
  webhookFeatures?: {
    receiveAllNotifications?: boolean;
    messageReceived?: boolean;
    messageCreate?: boolean;
    statusChange?: boolean;
    presenceChange?: boolean;
    deviceConnected?: boolean;
    receiveByEmail?: boolean;
  }
): Promise<{ status: string; message?: string; configured?: boolean; webhookUrl?: string; webhookFeatures?: any }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      console.log(`[Z-API] Erro: Credenciais nﾃ｣o configuradas para canal ${channel.id}`);
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Determinar a URL base da aplicaﾃｧﾃ｣o
    let baseUrl = '';
    if (process.env.APP_URL) {
      baseUrl = process.env.APP_URL;
    } else if (process.env.REPLIT_DOMAINS) {
      baseUrl = `https://${process.env.REPLIT_DOMAINS.split(',')[0]}`;
    } else {
      // URL da Replit atual baseada na ID do projeto
      baseUrl = 'https://0eb8be2b-04a6-47e5-bbf1-dd3bd83018b0-00-2m0jsmtd34bj0.picard.replit.dev';
    }
    
    // URL do webhook - garantindo que seja uma URL acessﾃｭvel externamente
    // e inclui o ID do canal para roteamento correto
    const finalWebhookUrl = webhookUrl || `${baseUrl}/api/webhooks/zapi/${channel.id}`;
    
    // Extrair features individuais para campos separados de acordo com a interface mostrada
    const features = webhookFeatures || {
      receiveAllNotifications: true,
      messageReceived: true,
      messageCreate: true,
      statusChange: true, 
      deviceConnected: true
    };
    
    console.log(`[Z-API] Configurando webhook para canal ${channel.id}:`);
    console.log(`[Z-API] URL do webhook: ${finalWebhookUrl}`);
    console.log(`[Z-API] Instﾃ｢ncia: ${instanceId}`);
    
    // Headers com o Client-Token correto - isso ﾃｩ fundamental para autenticaﾃｧﾃ｣o na API
    const headers = getHeadersWithToken(token, clientToken);
    console.log(`[Z-API] Headers para configuraﾃｧﾃ｣o do webhook:`, JSON.stringify(headers, null, 2));
    
    // Configurar o webhook na Z-API usando os endpoints conforme a documentaﾃｧﾃ｣o atual
    let webhookConfigured = false;
    let configError = null;
    
    // === CONFIGURAﾃﾃグ PRINCIPAL: Configurar o Webhook usando API mais recente ===
    // De acordo com a documentaﾃｧﾃ｣o atual da Z-API: webhook unificado
    try {
      console.log(`[Z-API] Configurando webhook usando a API unificada...`);
      
      // Configurar o webhook usando o endpoint e mﾃｩtodo atual
      const webhookConfig = {
        url: finalWebhookUrl,
        webhookFeatures: {
          receiveAllNotifications: features.receiveAllNotifications || true,
          messageReceived: features.messageReceived || true,
          messageCreate: features.messageCreate || true,
          statusChange: features.statusChange || true,
          presenceChange: features.presenceChange || true,
          deviceConnected: features.deviceConnected || true,
          receiveByEmail: features.receiveByEmail || false
        }
      };
      
      console.log(`[Z-API] Payload de configuraﾃｧﾃ｣o do webhook:`, JSON.stringify(webhookConfig, null, 2));
      
      // Usando mﾃｩtodo PUT em vez de POST como recomendado pela documentaﾃｧﾃ｣o mais recente
      const webhookResponse = await axios.put(
        `${BASE_URL}/instances/${instanceId}/token/${token}/webhook`,
        webhookConfig,
        { headers }
      );
      
      console.log(`[Z-API] Resposta da configuraﾃｧﾃ｣o do Webhook:`, 
        JSON.stringify(webhookResponse.data, null, 2));
      
      webhookConfigured = true;
    } catch (error) {
      if (error instanceof Error) {
        console.log("[Z-API] Erro na configuraﾃｧﾃ｣o do webhook via API unificada:", error.message);
        if (axios.isAxiosError(error)) {
          console.log("[Z-API] Detalhes do erro:", JSON.stringify(error.response?.data, null, 2));
          
          // Como estamos usando a API mais recente, tentar alternativa em caso de falha
          configError = error;
        }
      }
    }
    
    // Nﾃ｣o precisamos mais das etapas adicionais 2, 3, 4 jﾃ｡ que a nova API configura tudo em uma ﾃｺnica chamada
    // Se a primeira chamada falhar, tentaremos um mﾃｩtodo alternativo (fallback)
    if (!webhookConfigured) {
      try {
        console.log(`[Z-API] Tentativa alternativa: Configurando webhook usando mﾃｩtodo legado...`);
        
        // Tentar configurar usando endpoint de webhook simples (mﾃｩtodo alternativo)
        const fallbackResponse = await axios.post(
          `${BASE_URL}/instances/${instanceId}/token/${token}/webhook`,
          {
            url: finalWebhookUrl,
            // Incluir opﾃｧﾃｵes mais simples para versﾃｵes mais antigas da API
            enabled: true,
            messageTypes: ["all"]
          },
          { headers }
        );
        
        console.log(`[Z-API] Resposta da configuraﾃｧﾃ｣o alternativa de Webhook:`, 
          JSON.stringify(fallbackResponse.data, null, 2));
        
        // Se chegamos aqui, a configuraﾃｧﾃ｣o foi bem-sucedida
        webhookConfigured = true;
      } catch (fallbackError) {
        if (fallbackError instanceof Error) {
          console.log("[Z-API] Erro na configuraﾃｧﾃ｣o alternativa de webhook:", fallbackError.message);
          // Nﾃ｣o definimos configError aqui para tentar ainda outro mﾃｩtodo se necessﾃ｡rio
        }
      }
    }
    
    // MELHORIA: Atualizar metadados do canal para armazenar o status da configuraﾃｧﾃ｣o
    // Isso garante que mesmo que a API Z-API retorne erros na verificaﾃｧﾃ｣o do webhook,
    // ainda teremos informaﾃｧﾃｵes persistentes no banco de dados sobre a configuraﾃｧﾃ｣o
    try {
      // Importar db para atualizar o canal
      const { db } = await import("../../../db");
      const { channels } = await import("../../../shared/schema");
      const { eq } = await import("drizzle-orm");
      
      // Obter canal atualizado para ter metadados atuais
      const [currentChannel] = await db.select()
        .from(channels)
        .where(eq(channels.id, channel.id));
      
      // Preparar metadados com informaﾃｧﾃｵes de webhook
      const metadata = {
        ...(currentChannel?.metadata || {}),
        webhookConfigured: true,
        webhookUrl: finalWebhookUrl,
        webhookFeatures: features,
        lastWebhookSetup: new Date().toISOString(),
        lastSuccessfulConfiguration: new Date().toISOString(),
        // Garantir que os dados abaixo nﾃ｣o sejam perdidos caso jﾃ｡ existam
        webhookReceiveCount: currentChannel?.metadata?.webhookReceiveCount || 0,
        lastWebhookReceived: currentChannel?.metadata?.lastWebhookReceived || null,
        webhookConfigurationMethod: webhookConfigured ? 
          (currentChannel?.metadata?.webhookConfigurationMethod || "api") + "+db" : 
          "db_only"
      };
      
      // Atualizar o canal com a informaﾃｧﾃ｣o de webhook configurado
      await db.update(channels)
        .set({ metadata })
        .where(eq(channels.id, channel.id));
      
      console.log(`[Z-API] Metadados do canal atualizados com informaﾃｧﾃｵes do webhook:`, 
        JSON.stringify(metadata, null, 2));
    } catch (dbError) {
      if (dbError instanceof Error) {
        console.error("[Z-API] Erro ao atualizar metadados do canal:", dbError.message);
      }
      // Continuamos mesmo com erro de DB, nﾃ｣o ﾃｩ crﾃｭtico
    }
    
    // Se nﾃ｣o conseguimos configurar o webhook com nenhum mﾃｩtodo, retorna erro
    if (!webhookConfigured && configError) {
      return {
        status: "error",
        configured: false,
        message: `Falha ao configurar webhook: ${configError instanceof Error ? configError.message : "Erro desconhecido"}`
      };
    }
    
    return {
      status: "success",
      configured: true,
      webhookUrl: finalWebhookUrl,
      webhookFeatures: features,
      message: `Webhook configurado com sucesso para: ${finalWebhookUrl}`
    };
    
  } catch (error) {
    console.error("[Z-API] Erro ao configurar webhook:", error);
    let errorDetails = "Erro desconhecido ao configurar webhook";
    
    if (axios.isAxiosError(error)) {
      const responseData = error.response?.data;
      if (responseData) {
        errorDetails = responseData.error || responseData.message || error.message;
      } else {
        errorDetails = error.message;
      }
      console.error("[Z-API] Detalhes da resposta:", JSON.stringify(error.response?.data, null, 2));
    } else if (error instanceof Error) {
      errorDetails = error.message;
    }
    
    return {
      status: "error",
      configured: false,
      message: errorDetails
    };
  }
}

/**
 * Envia uma mensagem de teste para uma conversa na caixa de entrada
 * @param channel Canal para enviar a mensagem
 * @returns Objeto com status do envio
 */
/**
 * Envia uma mensagem de link via Z-API
 * @param channel Canal configurado
 * @param to Nﾃｺmero de telefone de destino
 * @param linkUrl URL do link a ser enviado
 * @param title Tﾃｭtulo opcional para o link (preview)
 * @param description Descriﾃｧﾃ｣o opcional para o link (preview)
 * @returns Status do envio com ID da mensagem
 */
/**
 * Envia uma mensagem com botﾃｵes via Z-API
 * @param channel Canal configurado
 * @param to Nﾃｺmero de telefone de destino
 * @param title Tﾃｭtulo da mensagem com botﾃｵes (obrigatﾃｳrio)
 * @param message Texto da mensagem principal
 * @param buttons Array de botﾃｵes com texto (de 1 a 3 botﾃｵes)
 * @param footer Texto de rodapﾃｩ (opcional)
 * @returns Status do envio com ID da mensagem
 */
export async function sendButtonMessage(
  channel: Channel,
  to: string,
  title: string,
  message: string,
  buttons: Array<{text: string}>,
  footer?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    // Verificar obrigatﾃｳrios
    if (!channel || !channel.config) {
      return {
        status: "error",
        message: "Configuraﾃｧﾃ｣o do canal invﾃ｡lida"
      };
    }

    if (!to) {
      return {
        status: "error",
        message: "Nﾃｺmero de destino obrigatﾃｳrio para mensagens com botﾃｵes"
      };
    }

    if (!title || !message) {
      return {
        status: "error",
        message: "Tﾃｭtulo e mensagem obrigatﾃｳrios para envio com botﾃｵes"
      };
    }

    if (!buttons || buttons.length < 1 || buttons.length > 3) {
      return {
        status: "error",
        message: "ﾃ necessﾃ｡rio fornecer de 1 a 3 botﾃｵes"
      };
    }

    // Extrair configuraﾃｧﾃｵes do canal
    const provider = channel.config.provider as string;
    if (provider !== "zapi") {
      return {
        status: "error",
        message: "Canal nﾃ｣o ﾃｩ Z-API"
      };
    }

    const instanceId = channel.config.instanceId as string;
    const token = channel.config.token as string;
    const clientToken = ZAPI_CLIENT_TOKEN;

    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas corretamente"
      };
    }

    // Formataﾃｧﾃ｣o correta do nﾃｺmero do WhatsApp
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    // Verificar se o nﾃｺmero ﾃｩ um grupo
    const isGroup = to.includes('-group') || to.includes('@g.us');
    
    // Se for um grupo, precisamos usar o ID do grupo sem formataﾃｧﾃ｣o
    if (isGroup) {
      formattedPhone = to;
      console.log(`[Z-API] Detectado grupo: ${formattedPhone}`);
    } else {
      console.log(`[Z-API] Enviando mensagem com botﾃｵes para: ${formattedPhone} (original: ${to})`);
    }
    
    // Headers completos para requisiﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de mensagem com botﾃｵes conforme documentaﾃｧﾃ｣o mais recente
    // Usamos send-button-list conforme a documentaﾃｧﾃ｣o enviada pelo usuﾃ｡rio
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-button-list`;
    
    // Transformar o formato de botﾃｵes para o formato esperado pela API
    const formattedButtons = formatButtonsForZAPI(buttons);
    
    // Payload no formato correto para send-button-list conforme documentaﾃｧﾃ｣o Z-API
    // https://developer.z-api.io/message/send-button-list
    const payload = {
      phone: formattedPhone,
      message: message, // Texto principal
      buttonText: "Clique aqui", // Texto do botﾃ｣o que exibe a lista (obrigatﾃｳrio)
      title: title,     // Tﾃｭtulo da lista de botﾃｵes
      footer: footer || "",
      buttons: formattedButtons
    };
    
    console.log("[Z-API] Enviando mensagem com botﾃｵes:", JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    // Verificar resposta da API
    if (response.data && response.data.id) {
      return {
        status: "success",
        message: "Mensagem com botﾃｵes enviada com sucesso",
        messageId: response.data.id
      };
    } else if (response.data && response.data.messageId) {
      return {
        status: "success",
        message: "Mensagem com botﾃｵes enviada com sucesso",
        messageId: response.data.messageId
      };
    } else if (response.data && response.data.zaapId) {
      return {
        status: "success",
        message: "Mensagem com botﾃｵes enviada com sucesso",
        messageId: response.data.zaapId
      };
    } else {
      console.error("[Z-API] Resposta sem ID da mensagem:", response.data);
      return {
        status: "warning",
        message: "Mensagem enviada, mas ID nﾃ｣o retornado"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar mensagem com botﾃｵes:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.message || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar mensagem com botﾃｵes"
    };
  }
}

/**
 * Envia uma mensagem com botﾃｵes e imagem via Z-API
 * @param channel Canal configurado
 * @param to Nﾃｺmero de telefone de destino
 * @param title Tﾃｭtulo da mensagem com botﾃｵes (obrigatﾃｳrio)
 * @param message Texto da mensagem principal
 * @param buttons Array de botﾃｵes com texto (de 1 a 3 botﾃｵes)
 * @param imageUrl URL da imagem a ser exibida
 * @param footer Texto de rodapﾃｩ (opcional)
 * @returns Status do envio com ID da mensagem
 */
export async function sendButtonImageMessage(
  channel: Channel,
  to: string,
  title: string,
  message: string,
  buttons: Array<{text: string}>,
  imageUrl: string,
  footer?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    // Verificar obrigatﾃｳrios
    if (!channel || !channel.config) {
      return {
        status: "error",
        message: "Configuraﾃｧﾃ｣o do canal invﾃ｡lida"
      };
    }

    if (!to) {
      return {
        status: "error",
        message: "Nﾃｺmero de destino obrigatﾃｳrio para mensagens com botﾃｵes e imagem"
      };
    }

    if (!title || !message) {
      return {
        status: "error",
        message: "Tﾃｭtulo e mensagem obrigatﾃｳrios para envio com botﾃｵes e imagem"
      };
    }

    if (!buttons || buttons.length < 1 || buttons.length > 3) {
      return {
        status: "error",
        message: "ﾃ necessﾃ｡rio fornecer de 1 a 3 botﾃｵes"
      };
    }

    if (!imageUrl) {
      return {
        status: "error",
        message: "URL da imagem obrigatﾃｳria para mensagens com botﾃｵes e imagem"
      };
    }

    // Extrair configuraﾃｧﾃｵes do canal
    const provider = channel.config.provider as string;
    if (provider !== "zapi") {
      return {
        status: "error",
        message: "Canal nﾃ｣o ﾃｩ Z-API"
      };
    }

    const instanceId = channel.config.instanceId as string;
    const token = channel.config.token as string;
    const clientToken = ZAPI_CLIENT_TOKEN;

    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas corretamente"
      };
    }

    // Formataﾃｧﾃ｣o correta do nﾃｺmero do WhatsApp
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    // Verificar se o nﾃｺmero ﾃｩ um grupo
    const isGroup = to.includes('-group') || to.includes('@g.us');
    
    // Se for um grupo, precisamos usar o ID do grupo sem formataﾃｧﾃ｣o
    if (isGroup) {
      formattedPhone = to;
      console.log(`[Z-API] Detectado grupo: ${formattedPhone}`);
    } else {
      console.log(`[Z-API] Enviando mensagem com botﾃｵes e imagem para: ${formattedPhone} (original: ${to})`);
    }
    
    // Headers completos para requisiﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de mensagem com botﾃｵes e imagem conforme documentaﾃｧﾃ｣o mais recente
    // Usamos send-button-list-image conforme a documentaﾃｧﾃ｣o
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-button-list-image`;
    
    // Verificar se ﾃｩ base64 ou URL
    const isBase64Image = imageUrl.startsWith('data:');
    
    // Transformar o formato de botﾃｵes para o formato esperado pela API
    const formattedButtons = formatButtonsForZAPI(buttons);
    
    // Payload no formato correto conforme documentaﾃｧﾃ｣o Z-API para send-button-list-image
    const payload = {
      phone: formattedPhone,
      image: imageUrl, // URL ou base64 da imagem
      message: message, // Texto principal
      // Usando o formato oficial conforme a documentaﾃｧﾃ｣o
      title: title,     // Tﾃｭtulo explﾃｭcito  
      footer: footer || "",
      buttons: formattedButtons // Botﾃｵes no formato correto
    };
    
    console.log(`[Z-API] Enviando mensagem com botﾃｵes e imagem (${isBase64Image ? 'Base64' : 'URL'}):`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    // Verificar resposta da API
    if (response.data && response.data.id) {
      return {
        status: "success",
        message: "Mensagem com botﾃｵes e imagem enviada com sucesso",
        messageId: response.data.id
      };
    } else if (response.data && response.data.messageId) {
      return {
        status: "success",
        message: "Mensagem com botﾃｵes e imagem enviada com sucesso",
        messageId: response.data.messageId
      };
    } else if (response.data && response.data.zaapId) {
      return {
        status: "success",
        message: "Mensagem com botﾃｵes e imagem enviada com sucesso",
        messageId: response.data.zaapId
      };
    } else {
      console.error("[Z-API] Resposta sem ID da mensagem:", response.data);
      return {
        status: "warning",
        message: "Mensagem enviada, mas ID nﾃ｣o retornado"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar mensagem com botﾃｵes e imagem:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.message || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar mensagem com botﾃｵes e imagem"
    };
  }
}

/**
 * Envia uma mensagem com botﾃｵes e vﾃｭdeo via Z-API
 * @param channel Canal configurado
 * @param to Nﾃｺmero de telefone de destino
 * @param title Tﾃｭtulo da mensagem com botﾃｵes (obrigatﾃｳrio)
 * @param message Texto da mensagem principal
 * @param buttons Array de botﾃｵes com texto (de 1 a 3 botﾃｵes)
 * @param videoUrl URL do vﾃｭdeo a ser exibido
 * @param footer Texto de rodapﾃｩ (opcional)
 * @returns Status do envio com ID da mensagem
 */
export async function sendButtonVideoMessage(
  channel: Channel,
  to: string,
  title: string,
  message: string,
  buttons: Array<{text: string}>,
  videoUrl: string,
  footer?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    // Verificar obrigatﾃｳrios
    if (!channel || !channel.config) {
      return {
        status: "error",
        message: "Configuraﾃｧﾃ｣o do canal invﾃ｡lida"
      };
    }

    if (!to) {
      return {
        status: "error",
        message: "Nﾃｺmero de destino obrigatﾃｳrio para mensagens com botﾃｵes e vﾃｭdeo"
      };
    }

    if (!title || !message) {
      return {
        status: "error",
        message: "Tﾃｭtulo e mensagem obrigatﾃｳrios para envio com botﾃｵes e vﾃｭdeo"
      };
    }

    if (!buttons || buttons.length < 1 || buttons.length > 3) {
      return {
        status: "error",
        message: "ﾃ necessﾃ｡rio fornecer de 1 a 3 botﾃｵes"
      };
    }

    if (!videoUrl) {
      return {
        status: "error",
        message: "URL do vﾃｭdeo obrigatﾃｳria para mensagens com botﾃｵes e vﾃｭdeo"
      };
    }

    // Extrair configuraﾃｧﾃｵes do canal
    const provider = channel.config.provider as string;
    if (provider !== "zapi") {
      return {
        status: "error",
        message: "Canal nﾃ｣o ﾃｩ Z-API"
      };
    }

    const instanceId = channel.config.instanceId as string;
    const token = channel.config.token as string;
    const clientToken = ZAPI_CLIENT_TOKEN;

    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas corretamente"
      };
    }

    // Formataﾃｧﾃ｣o correta do nﾃｺmero do WhatsApp
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    // Verificar se o nﾃｺmero ﾃｩ um grupo
    const isGroup = to.includes('-group') || to.includes('@g.us');
    
    // Se for um grupo, precisamos usar o ID do grupo sem formataﾃｧﾃ｣o
    if (isGroup) {
      formattedPhone = to;
      console.log(`[Z-API] Detectado grupo: ${formattedPhone}`);
    } else {
      console.log(`[Z-API] Enviando mensagem com botﾃｵes e vﾃｭdeo para: ${formattedPhone} (original: ${to})`);
    }
    
    // Headers completos para requisiﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de mensagem com botﾃｵes e vﾃｭdeo conforme documentaﾃｧﾃ｣o mais recente
    // Usamos send-button-list-video conforme a documentaﾃｧﾃ｣o
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-button-list-video`;
    
    // Verificar se ﾃｩ base64 ou URL
    const isBase64Video = videoUrl.startsWith('data:');
    
    // Transformar o formato de botﾃｵes para o formato esperado pela API
    const formattedButtons = formatButtonsForZAPI(buttons);
    
    // Payload no formato correto conforme documentaﾃｧﾃ｣o Z-API para send-button-list-video
    const payload = {
      phone: formattedPhone,
      video: videoUrl, // URL ou base64 do vﾃｭdeo
      message: message, // Texto principal
      // Usando o formato oficial conforme a documentaﾃｧﾃ｣o
      title: title,     // Tﾃｭtulo explﾃｭcito  
      footer: footer || "",
      buttons: formattedButtons // Botﾃｵes no formato correto
    };
    
    console.log(`[Z-API] Enviando mensagem com botﾃｵes e vﾃｭdeo (${isBase64Video ? 'Base64' : 'URL'}):`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    // Verificar resposta da API
    if (response.data && response.data.id) {
      return {
        status: "success",
        message: "Mensagem com botﾃｵes e vﾃｭdeo enviada com sucesso",
        messageId: response.data.id
      };
    } else if (response.data && response.data.messageId) {
      return {
        status: "success",
        message: "Mensagem com botﾃｵes e vﾃｭdeo enviada com sucesso",
        messageId: response.data.messageId
      };
    } else if (response.data && response.data.zaapId) {
      return {
        status: "success",
        message: "Mensagem com botﾃｵes e vﾃｭdeo enviada com sucesso",
        messageId: response.data.zaapId
      };
    } else {
      console.error("[Z-API] Resposta sem ID da mensagem:", response.data);
      return {
        status: "warning",
        message: "Mensagem enviada, mas ID nﾃ｣o retornado"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar mensagem com botﾃｵes e vﾃｭdeo:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.message || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar mensagem com botﾃｵes e vﾃｭdeo"
    };
  }
}

/**
 * Envia uma mensagem com lista de opﾃｧﾃｵes via Z-API
 * @param channel Canal configurado
 * @param to Nﾃｺmero de telefone de destino
 * @param message Texto da mensagem
 * @param title Tﾃｭtulo da lista
 * @param buttonText Texto do botﾃ｣o (para abrir a lista)
 * @param sections Seﾃｧﾃｵes da lista com opﾃｧﾃｵes
 * @param footer Texto de rodapﾃｩ (opcional)
 * @returns Status do envio com ID da mensagem
 */
export async function sendOptionList(
  channel: Channel,
  to: string,
  message: string,
  title: string,
  buttonText: string,
  sections: Array<{
    title: string;
    rows: Array<{
      title: string;
      description?: string;
      id: string;
    }>
  }>,
  footer?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    // Verificar obrigatﾃｳrios
    if (!channel || !channel.config) {
      return {
        status: "error",
        message: "Configuraﾃｧﾃ｣o do canal invﾃ｡lida"
      };
    }

    if (!to) {
      return {
        status: "error",
        message: "Nﾃｺmero de destino obrigatﾃｳrio para mensagens com lista de opﾃｧﾃｵes"
      };
    }

    if (!message || !title || !buttonText || !sections || sections.length === 0) {
      return {
        status: "error",
        message: "Mensagem, tﾃｭtulo, texto do botﾃ｣o e ao menos uma seﾃｧﾃ｣o sﾃ｣o obrigatﾃｳrios"
      };
    }

    // Verificar se pelo menos uma seﾃｧﾃ｣o tem opﾃｧﾃｵes
    let hasSomeOptions = false;
    for (const section of sections) {
      if (section.rows && section.rows.length > 0) {
        hasSomeOptions = true;
        break;
      }
    }

    if (!hasSomeOptions) {
      return {
        status: "error",
        message: "ﾃ necessﾃ｡rio incluir pelo menos uma opﾃｧﾃ｣o em alguma seﾃｧﾃ｣o"
      };
    }

    // Extrair configuraﾃｧﾃｵes do canal
    const provider = channel.config.provider as string;
    if (provider !== "zapi") {
      return {
        status: "error",
        message: "Canal nﾃ｣o ﾃｩ Z-API"
      };
    }

    const instanceId = channel.config.instanceId as string;
    const token = channel.config.token as string;
    const clientToken = ZAPI_CLIENT_TOKEN;

    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas corretamente"
      };
    }

    // Formataﾃｧﾃ｣o correta do nﾃｺmero do WhatsApp
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    // Verificar se o nﾃｺmero ﾃｩ um grupo
    const isGroup = to.includes('-group') || to.includes('@g.us');
    
    // Se for um grupo, precisamos usar o ID do grupo sem formataﾃｧﾃ｣o
    if (isGroup) {
      formattedPhone = to;
      console.log(`[Z-API] Detectado grupo: ${formattedPhone}`);
    } else {
      console.log(`[Z-API] Enviando lista de opﾃｧﾃｵes para: ${formattedPhone} (original: ${to})`);
    }
    
    // Headers completos para requisiﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de lista de opﾃｧﾃｵes
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-option-list`;
    
    // Payload conforme documentaﾃｧﾃ｣o Z-API para send-option-list
    const payload = {
      phone: formattedPhone,
      message: message, // Texto principal
      title: title, // Tﾃｭtulo da lista
      buttonText: buttonText, // Texto do botﾃ｣o para abrir a lista
      sections: sections, // Seﾃｧﾃｵes com opﾃｧﾃｵes
      footer: footer || "" // Rodapﾃｩ opcional
    };
    
    console.log("[Z-API] Enviando lista de opﾃｧﾃｵes:", JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    // Verificar resposta da API
    if (response.data && response.data.id) {
      return {
        status: "success",
        message: "Lista de opﾃｧﾃｵes enviada com sucesso",
        messageId: response.data.id
      };
    } else if (response.data && response.data.messageId) {
      return {
        status: "success",
        message: "Lista de opﾃｧﾃｵes enviada com sucesso",
        messageId: response.data.messageId
      };
    } else if (response.data && response.data.zaapId) {
      return {
        status: "success",
        message: "Lista de opﾃｧﾃｵes enviada com sucesso",
        messageId: response.data.zaapId
      };
    } else {
      console.error("[Z-API] Resposta sem ID da mensagem:", response.data);
      return {
        status: "warning",
        message: "Lista de opﾃｧﾃｵes enviada, mas ID nﾃ｣o retornado"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar lista de opﾃｧﾃｵes:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.message || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar lista de opﾃｧﾃｵes"
    };
  }
}

export async function sendLinkMessage(
  channel: Channel,
  to: string,
  linkUrl: string,
  title?: string,
  description?: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Formataﾃｧﾃ｣o do nﾃｺmero do WhatsApp conforme documentaﾃｧﾃ｣o
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API] Enviando link para ${formattedPhone} (original: ${to}): "${linkUrl}"`);
    console.log(`[Z-API] Tﾃｭtulo: "${title || 'sem tﾃｭtulo'}"`);
    console.log(`[Z-API] Descriﾃｧﾃ｣o: "${description || 'sem descriﾃｧﾃ｣o'}"`);
    
    // Headers completos para requisiﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para envio de link
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/send-link`;
    console.log(`[Z-API] Chamando endpoint: ${endpoint}`);
    
    // Payload conforme documentaﾃｧﾃ｣o da Z-API
    const payload = {
      phone: formattedPhone,
      message: linkUrl,      // URL do link
      linkUrl: linkUrl,      // URL do link (duplicado para compatibilidade com diferentes versﾃｵes da API)
      title: title || '',     // Tﾃｭtulo opcional
      description: description || ''  // Descriﾃｧﾃ｣o opcional
    };
    
    console.log(`[Z-API] Enviando payload:`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    console.log(`[Z-API] Resposta de envio de link:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme documentaﾃｧﾃ｣o
    if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
      const messageId = response.data.messageId || response.data.id || response.data.zaapId;
      console.log(`[Z-API] Link enviado com sucesso, ID: ${messageId}`);
      return {
        status: "success",
        messageId: messageId
      };
    } else if (response.data && response.data.value === true) {
      // Algumas versﾃｵes da API retornam o campo value como true para indicar sucesso
      console.log(`[Z-API] Link enviado com sucesso, resposta sem ID (usar Z-API mais recente)`);
      return {
        status: "success",
        messageId: "unknown" // Nﾃ｣o temos ID neste caso
      };
    } else {
      console.error(`[Z-API] Resposta de erro ao enviar link:`, response.data);
      return {
        status: "error",
        message: "Falha ao enviar link via Z-API: Resposta sem ID de mensagem"
      };
    }
  } catch (error) {
    console.error("Erro ao enviar link Z-API:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao enviar link Z-API"
    };
  }
}

/**
 * Encaminha uma mensagem previamente enviada/recebida via Z-API
 * @param channel Canal configurado
 * @param to Nﾃｺmero de telefone de destino
 * @param messageId ID da mensagem original a ser encaminhada
 * @returns Status do encaminhamento com ID da nova mensagem
 */
export async function forwardMessage(
  channel: Channel,
  to: string,
  messageId: string
): Promise<{ status: string; message?: string; messageId?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    // Formataﾃｧﾃ｣o do nﾃｺmero do WhatsApp conforme documentaﾃｧﾃ｣o
    let formattedPhone = to.replace(/\D/g, '');
    
    // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
    if (formattedPhone.length <= 11) {
      formattedPhone = `55${formattedPhone}`;
    }
    
    console.log(`[Z-API] Encaminhando mensagem para ${formattedPhone} (original: ${to})`);
    console.log(`[Z-API] MessageID a ser encaminhado: ${messageId}`);
    
    // Headers completos para requisiﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para encaminhamento de mensagem
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/forward-message`;
    console.log(`[Z-API] Chamando endpoint: ${endpoint}`);
    
    // Payload conforme documentaﾃｧﾃ｣o da Z-API
    const payload = {
      phone: formattedPhone,
      messageId: messageId
    };
    
    console.log(`[Z-API] Enviando payload:`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    console.log(`[Z-API] Resposta de encaminhamento:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme documentaﾃｧﾃ｣o
    if (response.data && (response.data.messageId || response.data.id || response.data.zaapId)) {
      const forwardedMessageId = response.data.messageId || response.data.id || response.data.zaapId;
      console.log(`[Z-API] Mensagem encaminhada com sucesso, ID: ${forwardedMessageId}`);
      return {
        status: "success",
        messageId: forwardedMessageId
      };
    } else if (response.data && response.data.value === true) {
      // Algumas versﾃｵes da API retornam o campo value como true para indicar sucesso
      console.log(`[Z-API] Mensagem encaminhada com sucesso, resposta sem ID (usar Z-API mais recente)`);
      return {
        status: "success",
        messageId: "unknown" // Nﾃ｣o temos ID neste caso
      };
    } else {
      console.error(`[Z-API] Resposta de erro ao encaminhar mensagem:`, response.data);
      return {
        status: "error",
        message: "Falha ao encaminhar mensagem via Z-API: Resposta sem ID de mensagem"
      };
    }
  } catch (error) {
    console.error("Erro ao encaminhar mensagem via Z-API:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao encaminhar mensagem Z-API"
    };
  }
}

/**
 * Exclui uma mensagem previamente enviada via Z-API
 * @param channel Canal configurado
 * @param messageId ID da mensagem a ser excluﾃｭda
 * @param phone Nﾃｺmero de telefone opcional (necessﾃ｡rio para alguns endpoints da Z-API)
 * @returns Status da exclusﾃ｣o
 */
export async function deleteMessage(
  channel: Channel,
  messageId: string,
  phone?: string
): Promise<{ status: string; message?: string }> {
  try {
    const instanceId = channel.config?.instanceId || ZAPI_INSTANCE_ID;
    const token = channel.config?.token || ZAPI_TOKEN;
    const clientToken = channel.config?.clientToken || ZAPI_CLIENT_TOKEN;
    
    if (!instanceId || !token) {
      return {
        status: "error",
        message: "Credenciais Z-API nﾃ｣o configuradas"
      };
    }
    
    console.log(`[Z-API] Excluindo mensagem com ID: ${messageId}`);
    
    // Headers completos para requisiﾃｧﾃ｣o
    const headers = {
      'Content-Type': 'application/json',
      'Client-Token': clientToken
    };
    
    // Endpoint para excluir mensagem (conforme documentaﾃｧﾃ｣o Z-API atualizada)
    // O endpoint correto ﾃｩ /message/delete (nova versﾃ｣o da API)
    const endpoint = `${BASE_URL}/instances/${instanceId}/token/${token}/message/delete`;
    console.log(`[Z-API] Chamando endpoint: ${endpoint}`);
    
    // Payload conforme documentaﾃｧﾃ｣o atualizada da Z-API
    // https://developer.z-api.io/message/delete-message
    const payload: any = {
      messageId: messageId,
      // Configura para nﾃ｣o aparecer para todos (false = remove para todos os participantes)
      onlyForMe: false
    };
    
    // ﾃ essencial incluir o nﾃｺmero de telefone no payload para identificar corretamente o destinatﾃ｡rio
    if (phone) {
      let formattedPhone = phone.replace(/\D/g, '');
      
      // Se o nﾃｺmero nﾃ｣o tiver o cﾃｳdigo do paﾃｭs, adiciona o cﾃｳdigo do Brasil (55)
      if (formattedPhone.length <= 11) {
        formattedPhone = `55${formattedPhone}`;
      }
      
      payload.phone = formattedPhone;
      console.log(`[Z-API] Incluindo nﾃｺmero de telefone: ${formattedPhone} (original: ${phone})`);
    } else {
      console.warn(`[Z-API] Aviso: Nﾃｺmero de telefone nﾃ｣o fornecido para exclusﾃ｣o da mensagem ${messageId}`);
      // Continuamos mesmo sem o telefone, mas ﾃｩ recomendado incluﾃｭ-lo
    }
    
    console.log(`[Z-API] Enviando payload:`, JSON.stringify(payload, null, 2));
    
    const response = await axios.post(endpoint, payload, { headers });
    
    console.log(`[Z-API] Resposta da exclusﾃ｣o de mensagem:`, JSON.stringify(response.data, null, 2));
    
    // Verificar resposta conforme documentaﾃｧﾃ｣o Z-API atualizada
    // A resposta para message/delete ﾃｩ diferente dos outros endpoints e retorna { value: true } se for bem-sucedida
    
    if (response.data && (response.data.value === true || response.status === 200)) {
      console.log(`[Z-API] Mensagem excluﾃｭda com sucesso`);
      
      return {
        status: "success",
        message: "Mensagem excluﾃｭda com sucesso"
      };
    } else {
      console.error(`[Z-API] Erro na resposta da exclusﾃ｣o de mensagem:`, response.data);
      
      return {
        status: "error",
        message: "Falha ao excluir mensagem: resposta invﾃ｡lida da Z-API"
      };
    }
  } catch (error) {
    console.error("Erro ao excluir mensagem Z-API:", error);
    
    // Log detalhado para diagnﾃｳstico
    if (axios.isAxiosError(error)) {
      console.error(`[Z-API] Status: ${error.response?.status}`);
      console.error(`[Z-API] Dados:`, error.response?.data);
      
      return {
        status: "error",
        message: `Erro Z-API: ${error.response?.status || ''} - ${error.response?.data?.error || error.message || "Erro na requisiﾃｧﾃ｣o"}`
      };
    }
    
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao excluir mensagem Z-API"
    };
  }
}

export async function sendTestMessageToInbox(channel: Channel): Promise<{ status: string; message?: string }> {
  try {
    // Primeiro verificamos se o canal estﾃ｡ conectado
    const connectionStatus = await checkConnectionStatus(channel);
    
    if (connectionStatus.status === "error" || !connectionStatus.connected) {
      return { 
        status: "error", 
        message: "Canal nﾃ｣o estﾃ｡ conectado. Conecte o WhatsApp antes de testar a caixa de entrada." 
      };
    }
    
    // Em uma implementaﾃｧﾃ｣o real, aqui enviarﾃｭamos uma mensagem para um nﾃｺmero especﾃｭfico
    // e aguardarﾃｭamos o recebimento pelo webhook. Como ﾃｩ um teste, vamos simular.
    
    // Verificar se o webhook estﾃ｡ configurado
    const webhookStatus = await checkWebhookStatus(channel);
    
    if (webhookStatus.status === "error" || !webhookStatus.configured) {
      return {
        status: "error",
        message: "Webhook nﾃ｣o estﾃ｡ configurado. Configure-o antes de testar a caixa de entrada."
      };
    }
    
    return {
      status: "success",
      message: "Teste de mensagem para caixa de entrada realizado com sucesso. Se o webhook estiver configurado corretamente, vocﾃｪ receberﾃ｡ as mensagens."
    };
  } catch (error) {
    console.error("Erro ao testar mensagem na caixa de entrada:", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Erro desconhecido ao testar mensagem"
    };
  }
}